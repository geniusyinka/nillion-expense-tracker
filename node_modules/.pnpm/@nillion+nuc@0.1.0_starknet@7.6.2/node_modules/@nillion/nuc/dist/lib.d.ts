import z$1, { z, Schema, ZodError } from 'zod';
import { Temporal } from 'temporal-polyfill';
import * as effect_Cause from 'effect/Cause';
import * as effect_Types from 'effect/Types';
import { Effect } from 'effect';
import { SigningStargateClient } from '@cosmjs/stargate';
import { OfflineSigner } from '@cosmjs/proto-signing';
import { Window } from '@keplr-wallet/types';

type SelectorTarget = "token" | "context";
declare const SelectorSchema: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>;
/**
 * A selector that specifies a path within a JSON object to be matched.
 */
declare class Selector {
    private readonly path;
    private readonly target;
    constructor(path: Array<string>, target: SelectorTarget);
    /**
     * Apply a selector on a value and return the matched value, if any.
     * @param value The value that this selector could be applied to.
     * @param context The context that this selector could be applied to.
     */
    apply<T = unknown>(value: T, context: Record<string, T>): T;
    static applyOnValue<T = unknown>(path: Array<string>, value: T): T;
    /**
     * Convert this selector into a string.
     */
    toString(): string;
}

/**
 * A policy that restricts how a NUC can be used.
 */
interface Policy {
    /**
     * Checks whether this policy matches a value.
     * @param record Value against the policy is matched.
     * @param context Application context against the policy is matched.
     */
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    /**
     *  Serialize the policy into an array of anything.
     */
    serialize(): Array<unknown>;
    /**
     * Serialize the policy into a string.
     */
    toString(): string;
}
/**
 * A policy that applies a selector on the NUC token and applies an operator to it.
 */
interface OperatorPolicy extends Policy {
}
declare const EqualsSchema: z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"==">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodUnknown], null>, Equals, ["==", string, unknown]>;
/**
 * An operator that checks for equality.
 */
declare class Equals implements OperatorPolicy {
    private readonly selector;
    private readonly value;
    constructor(selector: Selector, value: unknown);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const NotEqualsSchema: z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"!=">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodUnknown], null>, NotEquals, ["!=", string, unknown]>;
/**
 * An operator that checks for inequality.
 */
declare class NotEquals implements OperatorPolicy {
    private readonly selector;
    private readonly value;
    constructor(selector: Selector, value: unknown);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const AnyOfSchema: z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"anyOf">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodArray<z.ZodUnknown, "many">], null>, AnyOf, ["anyOf", string, unknown[]]>;
/**
 * An operator that checks that a value is within a list of values.
 */
declare class AnyOf implements OperatorPolicy {
    private readonly selector;
    readonly options: Array<unknown>;
    constructor(selector: Selector, options: Array<unknown>);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const OperatorSchema: z.ZodUnion<[z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"==">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodUnknown], null>, Equals, ["==", string, unknown]>, z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"!=">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodUnknown], null>, NotEquals, ["!=", string, unknown]>, z.ZodEffects<z.ZodTuple<[z.ZodLiteral<"anyOf">, z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    selector: string;
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, {
    labels: string[];
    target: SelectorTarget;
}, string>, Selector, string>, z.ZodArray<z.ZodUnknown, "many">], null>, AnyOf, ["anyOf", string, unknown[]]>]>;
/**
 * Represents a connector of policies.
 */
interface ConnectorPolicy extends Policy {
}
declare const AndSchema: z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"and">, z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">], null>>, And, ["and", unknown[]]>;
/**
 * A connector that checks that a sequence of policies is valid.
 */
declare class And implements ConnectorPolicy {
    readonly conditions: Array<Policy>;
    constructor(conditions: Array<Policy>);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const OrSchema: z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"or">, z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">], null>>, Or, ["or", unknown[]]>;
/**
 * A connector that checks that at least policy in a sequence is valid.
 */
declare class Or implements ConnectorPolicy {
    readonly conditions: Array<Policy>;
    constructor(conditions: Array<Policy>);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const NotSchema: z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"not">, z.ZodType<unknown, z.ZodTypeDef, unknown>], null>>, Not, ["not", unknown]>;
/**
 * A connector that checks that at a policy is not valid.
 */
declare class Not implements ConnectorPolicy {
    readonly condition: Policy;
    constructor(condition: Policy);
    evaluate(record: Record<string, unknown>, context: Record<string, unknown>): boolean;
    serialize(): Array<unknown>;
    toString(): string;
}
declare const ConnectorSchema: z.ZodLazy<z.ZodUnion<[z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"and">, z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">], null>>, And, ["and", unknown[]]>, z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"or">, z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">], null>>, Or, ["or", unknown[]]>, z.ZodEffects<z.ZodLazy<z.ZodTuple<[z.ZodLiteral<"not">, z.ZodType<unknown, z.ZodTypeDef, unknown>], null>>, Not, ["not", unknown]>]>>;
declare const PolicySchema: z.ZodType<unknown>;

declare const NilauthUnreachable_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "NilauthUnreachable";
} & Readonly<A>;
/**
 * Error thrown when a service cannot be contacted.
 * Used when network requests fail to establish a connection to the target.
 *
 * @property url - Target server URL.
 * @property cause - The original error that caused the failure (optional).
 */
declare class NilauthUnreachable extends NilauthUnreachable_base<{
    url: string;
    cause?: unknown;
}> {
    /**
     * Returns a formatted string for logging.
     */
    toString(): string;
}
declare const InvalidContentType_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "InvalidContentType";
} & Readonly<A>;
/**
 * Error thrown when the response content type does not match expectations.
 *
 * @property actual - The actual content type received.
 * @property expected - The expected content type.
 * @property response - The original Response object.
 * @property cause - The underlying error.
 */
declare class InvalidContentType extends InvalidContentType_base<{
    actual: string | null;
    expected: "application/json" | "plain/text";
    response: globalThis.Response;
    cause: Error;
}> {
    /**
     * Returns a formatted string for logging.
     */
    toString(): string;
}
declare const PaymentTxFailed_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "PaymentTxFailed";
} & Readonly<A>;
/**
 * Error thrown when a payment transaction fails.
 *
 * @property cause - The underlying error or reason for the failure.
 */
declare class PaymentTxFailed extends PaymentTxFailed_base<{
    cause: unknown;
}> {
    /**
     * Returns a formatted string for logging.
     */
    toString(): string;
}
/**
 * Zod schema and type for all known Nilauth error codes returned by the server.
 */
declare const NilauthErrorCodeSchema: z.ZodEnum<["CANNOT_RENEW_YET", "HASH_MISMATCH", "INSUFFICIENT_PAYMENT", "INTERNAL", "INVALID_PUBLIC_KEY", "MALFORMED_PAYLOAD", "MALFORMED_TRANSACTION", "NOT_SUBSCRIBED", "PAYMENT_ALREADY_PROCESSED", "TRANSACTION_LOOKUP", "TRANSACTION_NOT_COMMITTED", "UNKNOWN_PUBLIC_KEY"]>;
type NilauthErrorCode = z.infer<typeof NilauthErrorCodeSchema>;
declare const NilauthErrorResponse_base: new <A extends Record<string, any> = {}>(args: effect_Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" ? never : P]: A[P]; }) => effect_Cause.YieldableError & {
    readonly _tag: "NilauthErrorResponse";
} & Readonly<A>;
/**
 * Error thrown when the Nilauth server returns a structured error response.
 *
 * @property url - The request URL.
 * @property code - The error code returned by the server.
 * @property message - The error message returned by the server.
 * @property status - The HTTP status code.
 * @property cause - The underlying error or response body (optional).
 */
declare class NilauthErrorResponse extends NilauthErrorResponse_base<{
    url: string;
    code: NilauthErrorCode;
    message: string;
    status: number;
    cause?: unknown;
}> {
    /**
     * Returns a formatted string for logging.
     */
    toString(): string;
}

/**
 * Represents a secp256k1 elliptic curve key pair with secure key handling
 */
declare class Keypair {
    #private;
    /**
     * Creates a Keypair instance from a valid 32-byte private key
     * @param privateKey - The private key as raw bytes
     */
    constructor(privateKey: Uint8Array);
    /**
     * Get private key in specified format
     * @param format - Output encoding (default: bytes in an Uint8Array)
     * @returns Private key in requested format
     */
    privateKey(format?: "bytes"): Uint8Array;
    privateKey(format: "hex"): string;
    /**
     * Get public key in specified format
     * @param format - Output encoding (default: bytes in an Uint8Array)
     * @returns Public key in requested format
     */
    publicKey(format?: "bytes"): Uint8Array;
    publicKey(format: "hex"): string;
    /**
     * Returns true if this keypair matches the provided public key
     */
    matchesPublicKey(pk: Uint8Array | string): boolean;
    /**
     * Returns a Did
     */
    toDid(): Did;
    /**
     * Returns a stringified Did, e.g., did:nil:<public_key_as_hex>
     */
    toDidString(): DidString;
    /**
     * Creates a Keypair from a private key
     * @param privateKey - The private key as hex string or raw bytes
     * @returns New Keypair instance
     */
    static from(privateKey: Uint8Array): Keypair;
    static from(privateKey: string): Keypair;
    /**
     * Generates a new cryptographically secure random key pair
     * @returns A new Keypair instance
     */
    static generate(): Keypair;
    /**
     * Signs a message
     * @param msg Message to sign
     * @param signatureFormat Result format. Only "hex" and "bytes" are valid (default: bytes in an Uint8Array).
     * @return The signature in raw bytes or hex string, depending on the given format.
     */
    sign(msg: string, signatureFormat?: "bytes"): Uint8Array;
    sign(msg: string, signatureFormat: "hex"): string;
}

declare const PublicKeySchema: z$1.ZodBranded<z$1.ZodString, "PublicKey">;
type PublicKey = z$1.infer<typeof PublicKeySchema>;
type SignedRequest = {
    public_key: string;
    signature: string;
    payload: string;
};
declare const NilauthHealthResponseSchema: z$1.ZodLiteral<"OK">;
type NilauthHealthResponse = z$1.infer<typeof NilauthHealthResponseSchema>;
declare const BuildSchema: z$1.ZodEffects<z$1.ZodObject<{
    commit: z$1.ZodString;
    timestamp: z$1.ZodString;
}, "strip", z$1.ZodTypeAny, {
    commit: string;
    timestamp: string;
}, {
    commit: string;
    timestamp: string;
}>, {
    commit: string;
    timestamp: Temporal.Instant;
}, {
    commit: string;
    timestamp: string;
}>;
declare const NilauthAboutResponseSchema: z$1.ZodEffects<z$1.ZodObject<{
    started: z$1.ZodString;
    public_key: z$1.ZodBranded<z$1.ZodString, "PublicKey">;
    build: z$1.ZodEffects<z$1.ZodObject<{
        commit: z$1.ZodString;
        timestamp: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        commit: string;
        timestamp: string;
    }, {
        commit: string;
        timestamp: string;
    }>, {
        commit: string;
        timestamp: Temporal.Instant;
    }, {
        commit: string;
        timestamp: string;
    }>;
}, "strip", z$1.ZodTypeAny, {
    started: string;
    public_key: string & z$1.BRAND<"PublicKey">;
    build: {
        commit: string;
        timestamp: Temporal.Instant;
    };
}, {
    started: string;
    public_key: string;
    build: {
        commit: string;
        timestamp: string;
    };
}>, {
    started: Temporal.Instant;
    publicKey: string & z$1.BRAND<"PublicKey">;
    build: {
        commit: string;
        timestamp: Temporal.Instant;
    };
}, {
    started: string;
    public_key: string;
    build: {
        commit: string;
        timestamp: string;
    };
}>;
type NilauthAboutResponse = z$1.output<typeof NilauthAboutResponseSchema>;
declare const ValidatePaymentResponseSchema: z$1.ZodEffects<z$1.ZodNull, void, null>;
type ValidatePaymentResponse = z$1.infer<typeof ValidatePaymentResponseSchema>;
declare const SubscriptionCostResponseSchema: z$1.ZodEffects<z$1.ZodObject<{
    cost_unils: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
    cost_unils: number;
}, {
    cost_unils: number;
}>, number, {
    cost_unils: number;
}>;
type SubscriptionCostResponse = z$1.output<typeof SubscriptionCostResponseSchema>;
declare const SubscriptionDetailsSchema: z$1.ZodEffects<z$1.ZodObject<{
    expires_at: z$1.ZodNumber;
    renewable_at: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
    expires_at: number;
    renewable_at: number;
}, {
    expires_at: number;
    renewable_at: number;
}>, {
    expiresAt: Temporal.Instant;
    renewableAt: Temporal.Instant;
}, {
    expires_at: number;
    renewable_at: number;
}>;
type SubscriptionDetails = z$1.infer<typeof SubscriptionDetailsSchema>;
declare const SubscriptionStatusResponseSchema: z$1.ZodObject<{
    subscribed: z$1.ZodBoolean;
    details: z$1.ZodNullable<z$1.ZodEffects<z$1.ZodObject<{
        expires_at: z$1.ZodNumber;
        renewable_at: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        expires_at: number;
        renewable_at: number;
    }, {
        expires_at: number;
        renewable_at: number;
    }>, {
        expiresAt: Temporal.Instant;
        renewableAt: Temporal.Instant;
    }, {
        expires_at: number;
        renewable_at: number;
    }>>;
}, "strip", z$1.ZodTypeAny, {
    subscribed: boolean;
    details: {
        expiresAt: Temporal.Instant;
        renewableAt: Temporal.Instant;
    } | null;
}, {
    subscribed: boolean;
    details: {
        expires_at: number;
        renewable_at: number;
    } | null;
}>;
type SubscriptionStatusResponse = z$1.infer<typeof SubscriptionStatusResponseSchema>;
declare const CreateTokenResponseSchema: z$1.ZodObject<{
    token: z$1.ZodEffects<z$1.ZodEffects<z$1.ZodEffects<z$1.ZodEffects<z$1.ZodEffects<z$1.ZodString, string[], string>, string[], string>, DecodedNucToken[], string>, DecodedNucToken[], string>, NucTokenEnvelope, string>;
}, "strip", z$1.ZodTypeAny, {
    token: NucTokenEnvelope;
}, {
    token: string;
}>;
type CreateTokenResponse = z$1.infer<typeof CreateTokenResponseSchema>;
declare const RevokedTokenSchema: z$1.ZodEffects<z$1.ZodObject<{
    token_hash: z$1.ZodString;
    revoked_at: z$1.ZodNumber;
}, "strip", z$1.ZodTypeAny, {
    token_hash: string;
    revoked_at: number;
}, {
    token_hash: string;
    revoked_at: number;
}>, {
    tokenHash: string;
    revokedAt: Temporal.Instant;
}, {
    token_hash: string;
    revoked_at: number;
}>;
type RevokedToken = z$1.output<typeof RevokedTokenSchema>;
declare const LookupRevokedTokenResponseSchema: z$1.ZodObject<{
    revoked: z$1.ZodArray<z$1.ZodEffects<z$1.ZodObject<{
        token_hash: z$1.ZodString;
        revoked_at: z$1.ZodNumber;
    }, "strip", z$1.ZodTypeAny, {
        token_hash: string;
        revoked_at: number;
    }, {
        token_hash: string;
        revoked_at: number;
    }>, {
        tokenHash: string;
        revokedAt: Temporal.Instant;
    }, {
        token_hash: string;
        revoked_at: number;
    }>, "many">;
}, "strip", z$1.ZodTypeAny, {
    revoked: {
        tokenHash: string;
        revokedAt: Temporal.Instant;
    }[];
}, {
    revoked: {
        token_hash: string;
        revoked_at: number;
    }[];
}>;
type LookupRevokedTokenResponse = z$1.output<typeof LookupRevokedTokenResponseSchema>;

/**
 * Zod schema for validating hexadecimal strings.
 */
declare const HexSchema: z.ZodString;
/** Type for a validated hexadecimal string. */
type Hex = z.infer<typeof HexSchema>;
/**
 * Epoch timestamp in seconds.
 **/
declare const EpochSeconds: z.ZodNumber;
/**
 * Parses a value as an epoch timestamp in seconds.
 *
 * Validates that the value is an integer and does not exceed 1 trillion.
 * Throws a ZodError if validation fails.
 *
 * @param value - The value to parse as epoch seconds.
 * @returns The parsed epoch seconds as a number.
 * @throws Error if the value is not a valid epoch timestamp.
 * @example
 * parseEpochSeconds(1633036800) // Returns 1633036800
 * parseEpochSeconds("invalid") // Throws Error
 */
declare const parseEpochSeconds: (value: unknown) => number;
/**
 * Converts a UTF-8 string to hexadecimal.
 *
 * The string is first encoded as UTF-8 bytes, then each byte is
 * converted to its hexadecimal representation.
 *
 * @param data - The UTF-8 string to convert.
 * @returns Hexadecimal representation of the UTF-8 encoded bytes.
 * @example
 * toHex("hello") // Returns "68656c6c6f"
 * toHex("ðŸ”¥") // Returns "f09f94a5" (UTF-8 encoding of emoji)
 */
declare function toHex(data: string): Hex;
/**
 * Encodes input as URL-safe base64 without padding.
 *
 * Converts strings to UTF-8 bytes before encoding. The resulting
 * base64url string has padding characters (=) removed for URL safety.
 *
 * @param input - String or byte array to encode.
 * @returns URL-safe base64 encoded string without padding.
 * @example
 * base64UrlEncode("hello") // Returns "aGVsbG8"
 * base64UrlEncode(new Uint8Array([1, 2, 3])) // Returns "AQID"
 */
declare function base64UrlEncode(input: string | Uint8Array): string;
/**
 * Decodes a URL-safe base64 string into a UTF-8 string.
 *
 * Handles both padded and unpadded base64url strings. If input is a
 * Uint8Array, it's first decoded to a string before processing.
 *
 * @param input - Base64url string or bytes to decode.
 * @returns Decoded UTF-8 string.
 * @throws Error if the decoded bytes are not valid UTF-8.
 * @example
 * base64UrlDecode("aGVsbG8") // Returns "hello"
 * base64UrlDecode("aGVsbG8=") // Also returns "hello" (handles padding)
 */
declare function base64UrlDecode(input: string | Uint8Array): string;
/**
 * Decodes a URL-safe base64 string into raw bytes.
 *
 * Automatically adds padding if needed before decoding. Useful when
 * you need the raw binary data rather than a UTF-8 string.
 *
 * @param input - Base64url string to decode.
 * @returns Decoded bytes as Uint8Array.
 * @example
 * base64UrlDecodeToBytes("AQID") // Returns Uint8Array([1, 2, 3])
 */
declare function base64UrlDecodeToBytes(input: string): Uint8Array;
/**
 * Generates consecutive pairs for a given array.
 * For example: [a, b, c] => [[a, b], [b, c]]
 * @param input - The input array.
 * @returns Array of consecutive pairs.
 */
declare function pairwise<T>(input: Array<T>): Array<Array<T>>;
/**
 * Generates cryptographically secure random bytes using Web Crypto API.
 * @param size - Number of random bytes to generate.
 * @returns Uint8Array of random bytes.
 * @throws Error if Web Crypto API is not available.
 */
declare function randomBytes(size: number): Uint8Array;
/**
 * Pipeable combinator to parse the result of an Effect using a Zod schema.
 *
 * @param schema - The Zod schema to use for parsing.
 * @returns A function that takes Effect<unknown, E> and returns Effect<T, E | ZodError>
 */
declare function parseWithZodSchema<A, E>(schema: Schema): (effect: E.Effect<unknown, E>) => E.Effect<A, ZodError | E>;
/**
 * Pipeable combinator to parse a Fetch Response as JSON.
 *
 * @returns A function that takes Effect<Response, E> and returns Effect<any, E | InvalidContentType>
 */
declare function extractResponseJson<E>(): (effect: E.Effect<globalThis.Response, E>) => E.Effect<unknown, E | InvalidContentType>;
/**
 * Pipeable combinator to parse a Fetch Response as text.
 *
 * @returns A function that takes Effect<Response, E> and returns Effect<string, E | InvalidContentType>
 */
declare function extractResponseText<E>(): (effect: E.Effect<globalThis.Response, E>) => E.Effect<unknown, E | InvalidContentType>;
/**
 * Asserts the type of an Effect result at compile time.
 * Used for type narrowing in effectful pipelines.
 *
 * @returns A function that casts the Effect's output type.
 */
declare function assertType<B>(): <A, E>(effect: E.Effect<A, E>) => E.Effect<B, E>;
/**
 * Generates a random nonce as a hexadecimal string.
 * @returns Hexadecimal nonce string.
 */
declare function generateNonce(): Hex;
/**
 * Creates a signed request object from a payload and a keypair.
 *
 * @param payload - The payload to sign.
 * @param keypair - The keypair to use for signing.
 * @returns A SignedRequest object.
 */
declare function createSignedRequest(payload: Record<string, unknown>, keypair: Keypair): SignedRequest;
/**
 * Unwraps an Effect to a Promise, throwing on failure.
 * If the Effect fails, the error is thrown; otherwise, the value is returned.
 *
 * @param effect - The Effect to unwrap.
 * @returns Promise of the successful value, or throws the error.
 */
declare function unwrapEffect<A, E>(effect: E.Effect<A, E>): Promise<A>;

declare const DidSchema: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, RegExpExecArray | null, string>, RegExpExecArray, string>, Did, string>;
type DidString = `did:nil:${string}`;
/**
 * A class representing a Decentralized Identifier (DID).
 */
declare class Did {
    readonly publicKey: Uint8Array;
    /**
     *
     * Creates a new DID for the given public key.
     * @param publicKey Public key in bytes format.
     */
    constructor(publicKey: Uint8Array);
    /**
     * Convert this DID into a string.
     */
    toString(): DidString;
    /**
     * Get the public which this DID represents.
     */
    publicKeyAsHex(): string;
    /**
     * Check if this and another DID are equals.
     * @param other The other DID which will be used for the equality operation.
     */
    isEqual(other: Did): boolean;
    /**
     * Creates a new DID for the given public key.
     * @param hex Public key in hex format.
     */
    static fromHex(hex: Hex): Did;
}
declare const CommandSchema: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, string[], string>, string[], string>, Command, string>;
/**
 * A command to be invoked.
 */
declare class Command {
    readonly segments: Array<string>;
    constructor(segments: Array<string>);
    /**
     * Check if this command is an attenuation of another one.
     * @param other The command for which this command is attenuation.
     */
    isAttenuationOf(other: Command): boolean;
    /**
     * Convert this command into a string.
     */
    toString(): string;
}
declare const REVOKE_COMMAND: Command;
declare const InvocationBodySchema: z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodUnknown>, InvocationBody, Record<string, unknown>>;
/**
 * Body of an invocation token.
 */
declare class InvocationBody {
    readonly args: Record<string, unknown>;
    constructor(args: Record<string, unknown>);
}
declare const DelegationBodySchema: z.ZodEffects<z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">, DelegationBody, unknown[]>;
/**
 * Body of a delegation token.
 */
declare class DelegationBody {
    readonly policies: Array<Policy>;
    constructor(policies: Array<Policy>);
}
declare const NucTokenSchema: z.ZodEffects<z.ZodObject<{
    iss: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, RegExpExecArray | null, string>, RegExpExecArray, string>, Did, string>;
    aud: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, RegExpExecArray | null, string>, RegExpExecArray, string>, Did, string>;
    sub: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, RegExpExecArray | null, string>, RegExpExecArray, string>, Did, string>;
    nbf: z.ZodOptional<z.ZodNumber>;
    exp: z.ZodOptional<z.ZodNumber>;
    cmd: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, string[], string>, string[], string>, Command, string>;
    args: z.ZodOptional<z.ZodEffects<z.ZodRecord<z.ZodString, z.ZodUnknown>, InvocationBody, Record<string, unknown>>>;
    pol: z.ZodOptional<z.ZodEffects<z.ZodArray<z.ZodType<unknown, z.ZodTypeDef, unknown>, "many">, DelegationBody, unknown[]>>;
    meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    nonce: z.ZodString;
    prf: z.ZodDefault<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    iss: Did;
    aud: Did;
    sub: Did;
    cmd: Command;
    nonce: string;
    prf: string[];
    nbf?: number | undefined;
    exp?: number | undefined;
    args?: InvocationBody | undefined;
    pol?: DelegationBody | undefined;
    meta?: Record<string, unknown> | undefined;
}, {
    iss: string;
    aud: string;
    sub: string;
    cmd: string;
    nonce: string;
    nbf?: number | undefined;
    exp?: number | undefined;
    args?: Record<string, unknown> | undefined;
    pol?: unknown[] | undefined;
    meta?: Record<string, unknown> | undefined;
    prf?: string[] | undefined;
}>, NucToken, {
    iss: string;
    aud: string;
    sub: string;
    cmd: string;
    nonce: string;
    nbf?: number | undefined;
    exp?: number | undefined;
    args?: Record<string, unknown> | undefined;
    pol?: unknown[] | undefined;
    meta?: Record<string, unknown> | undefined;
    prf?: string[] | undefined;
}>;
declare const NucTokenDataSchema: z.ZodObject<{
    issuer: z.ZodType<Did, z.ZodTypeDef, Did>;
    audience: z.ZodType<Did, z.ZodTypeDef, Did>;
    subject: z.ZodType<Did, z.ZodTypeDef, Did>;
    notBefore: z.ZodOptional<z.ZodType<Temporal.Instant, z.ZodTypeDef, Temporal.Instant>>;
    expiresAt: z.ZodOptional<z.ZodType<Temporal.Instant, z.ZodTypeDef, Temporal.Instant>>;
    command: z.ZodType<Command, z.ZodTypeDef, Command>;
    body: z.ZodUnion<[z.ZodType<DelegationBody, z.ZodTypeDef, DelegationBody>, z.ZodType<InvocationBody, z.ZodTypeDef, InvocationBody>]>;
    meta: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    nonce: z.ZodString;
    proofs: z.ZodArray<z.ZodType<Uint8Array<ArrayBuffer>, z.ZodTypeDef, Uint8Array<ArrayBuffer>>, "many">;
}, "strip", z.ZodTypeAny, {
    nonce: string;
    issuer: Did;
    audience: Did;
    subject: Did;
    command: Command;
    body: InvocationBody | DelegationBody;
    proofs: Uint8Array<ArrayBuffer>[];
    expiresAt?: Temporal.Instant | undefined;
    meta?: Record<string, unknown> | undefined;
    notBefore?: Temporal.Instant | undefined;
}, {
    nonce: string;
    issuer: Did;
    audience: Did;
    subject: Did;
    command: Command;
    body: InvocationBody | DelegationBody;
    proofs: Uint8Array<ArrayBuffer>[];
    expiresAt?: Temporal.Instant | undefined;
    meta?: Record<string, unknown> | undefined;
    notBefore?: Temporal.Instant | undefined;
}>;
type NucTokenData = z.infer<typeof NucTokenDataSchema>;
/**
 * A class representing a NUC token.
 */
declare class NucToken {
    private readonly _data;
    constructor(_data: NucTokenData);
    get issuer(): Did;
    get audience(): Did;
    get subject(): Did;
    get command(): Command;
    get body(): InvocationBody | DelegationBody;
    get nonce(): Hex;
    get proofs(): Array<Uint8Array>;
    get notBefore(): Temporal.Instant | undefined;
    get expiresAt(): Temporal.Instant | undefined;
    get meta(): Record<string, unknown> | undefined;
    /**
     * Convert this token into JSON.
     */
    toJson(): Record<string, unknown>;
    /**
     * Convert this command into a string.
     */
    toString(): string;
}

declare const NucTokenEnvelopeSchema: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, string[], string>, string[], string>, DecodedNucToken[], string>, DecodedNucToken[], string>, NucTokenEnvelope, string>;
/**
 * A NUC token envelope, containing a parsed token along with all its proofs.
 */
declare class NucTokenEnvelope {
    readonly token: DecodedNucToken;
    readonly proofs: Array<DecodedNucToken>;
    constructor(token: DecodedNucToken, proofs: Array<DecodedNucToken>);
    /**
     * Validate the signature in this envelope.
     *
     * This will raise an exception is the token or any of its proofs is not signed by its issuer.
     */
    validateSignatures(): void;
    /**
     * Serialize this envelope as a JWT-like string.
     */
    serialize(): string;
}
declare const HeaderSchema: z.ZodObject<{
    alg: z.ZodLiteral<"ES256K">;
}, "strip", z.ZodTypeAny, {
    alg: "ES256K";
}, {
    alg: "ES256K";
}>;
declare const DecodedNucTokenSchema: z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodEffects<z.ZodString, string[], string>, string[], string>, string[], string>, DecodedNucToken, string>;
/**
 * A decoded NUC token.
 */
declare class DecodedNucToken {
    readonly rawHeader: string;
    readonly rawPayload: string;
    readonly signature: Uint8Array;
    readonly token: NucToken;
    constructor(rawHeader: string, rawPayload: string, signature: Uint8Array, token: NucToken);
    /**
     * Validate the signature in this token.
     */
    validateSignature(): void;
    /**
     * Compute the hash for this token.
     */
    computeHash(): Uint8Array;
    /**
     * Serialize this token as a JWT.
     */
    serialize(): string;
}

/**
 * Builder for a NUC token.
 */
declare class NucTokenBuilder {
    private _body;
    private _audience?;
    private _subject?;
    private _notBefore?;
    private _expiresAt?;
    private _command?;
    private _meta?;
    private _nonce?;
    private _proof?;
    private constructor();
    /**
     * Create a new token builder for a delegation token.
     * @param policies The policies to use in the delegation.
     */
    static delegation(policies: Array<Policy>): NucTokenBuilder;
    /**
     * Creates a new token builder for an invocation.
     * @param args The arguments to use in the invocation.
     */
    static invocation(args: Record<string, unknown>): NucTokenBuilder;
    /**
     * Create a NUC token builder that pulls basic properties from a given NUC token.
     *
     * This pulls the following properties from the given envelope:
     *
     *  * command
     *  * subject
     *
     * @param envelope The envelope to extend.
     */
    static extending(envelope: NucTokenEnvelope): NucTokenBuilder;
    /**
     * Set the audience for the token to be built.
     *
     * The audience must be the entity this token is going to be sent to.
     *
     * @param audience The audience of the token.
     */
    audience(audience: Did): NucTokenBuilder;
    /**
     * Set the body for the token being built.
     *
     * @param body The body for the token.
     */
    body(body: DelegationBody | InvocationBody): NucTokenBuilder;
    /**
     * Set the subject for the token to be built.
     *
     * @param subject The subject of the token.
     */
    subject(subject: Did): NucTokenBuilder;
    /**
     * Set the token's `not before` instant.
     *
     * @param epoch The Unix timestamp (in seconds) at which the token becomes valid.
     * @throws Error if the value is not a valid epoch timestamp.
     */
    notBefore(epoch: number): NucTokenBuilder;
    /**
     * Set the token's `expires at` instant.
     *
     * @param epoch The Unix timestamp (in seconds) at which the token expires.
     * @throws Error if the value is not a valid epoch timestamp.
     */
    expiresAt(epoch: number): NucTokenBuilder;
    /**
     * Set the command for the token to be built.
     *
     * @param command The command for the token to be built.
     */
    command(command: Command): NucTokenBuilder;
    /**
     * Set the metadata for the token to be built.
     *
     * @param meta The metadata for the built token.
     */
    meta(meta: Record<string, unknown>): NucTokenBuilder;
    /**
     * Set the nonce for the token to be built.
     *
     * @param nonce The nonce to be set.
     *
     * The nonce doesn't have to be explicitly set and it will default to a random 16 bytes long bytestring if not set.
     */
    nonce(nonce: Hex): NucTokenBuilder;
    /**
     * Set the proof for the token to be built.
     *
     * It's recommended to call :meth:`NucTokenBuilder.extending` which also takes care of pulling other important fields.
     *
     * @param proof The token to be used as proof.
     */
    proof(proof: NucTokenEnvelope): NucTokenBuilder;
    /**
     * Build the token, signing it using the given private key.
     *
     * @param key The key to use to sing the token.
     */
    build(key: Uint8Array): string;
}

type FetchError = NilauthUnreachable | NilauthErrorResponse;

declare const GasLimitSchema: z.ZodUnion<[z.ZodLiteral<"auto">, z.ZodNumber]>;
type GasLimit = z.infer<typeof GasLimitSchema>;
declare const TxHash: z.ZodBranded<z.ZodString, "TxHash">;
type TxHash = z.infer<typeof TxHash>;
declare const NilChainAddressPrefix = "nillion";
declare const NilChainAddress: z.ZodBranded<z.ZodString, "Address">;
type NilChainAddress = z.infer<typeof NilChainAddress>;
declare const NilToken: {
    Unil: string;
    asUnil: (amount: number | string) => string;
};
declare const NilChainProtobufTypeUrl = "/nillion.meta.v1.MsgPayFor";
declare const OfflineSignerSchema: z.ZodType<OfflineSigner, z.ZodTypeDef, OfflineSigner>;
declare const PrivateKeyBase16: z.ZodBranded<z.ZodString, "PrivateKeyBase16">;
type PrivateKeyBase16 = z.infer<typeof PrivateKeyBase16>;

declare const PayerConfigSchema: z.ZodObject<{
    address: z.ZodBranded<z.ZodString, "Address">;
    client: z.ZodType<SigningStargateClient, z.ZodTypeDef, SigningStargateClient>;
    gasLimit: z.ZodUnion<[z.ZodLiteral<"auto">, z.ZodNumber]>;
}, "strip", z.ZodTypeAny, {
    address: string & z.BRAND<"Address">;
    client: SigningStargateClient;
    gasLimit: number | "auto";
}, {
    address: string;
    client: SigningStargateClient;
    gasLimit: number | "auto";
}>;
/**
 * Payer configuration.
 *
 * @property {string} address  Nilchain address.
 * @property {SigningStargateClient} client Cosmos client to perform transactions in nilchain
 * @property {string} gasLimit Gas limit strategy auto a fixed value are allowed.
 */
type PayerConfig = z.infer<typeof PayerConfigSchema>;
/**
 * A payer that allows making payments on nilchain.
 */
declare class Payer {
    private readonly config;
    /**
     * Creates a Payer instance for the given configuration.
     *
     * @param config Payer configuration.
     */
    constructor(config: PayerConfig);
    /**
     * Peform a 'MsgPayFor' payment for the given resource.
     *
     * @param resource The resource to use in the transaction.
     * @param amountUnil The amount of unil to send in the payment.
     */
    pay(resource: Uint8Array, amountUnil: number): Promise<TxHash>;
}

type BlindModule = "nilai" | "nildb";
/**
 * Options required to construct a NilauthClient.
 */
type NilauthClientOptions = {
    payer: Payer;
    nilauth: {
        baseUrl: string;
        publicKey: PublicKey;
    };
};
/**
 * Client for interacting with the Nilauth service.
 *
 * Provides methods for health checks, subscription management, payments,
 * token issuance, revocation, and proof chain validation.
 * Uses effectful, composable pipelines for all network operations with
 * consistent error handling and typed responses.
 */
declare class NilauthClient {
    #private;
    /**
     * Initialize a NilauthClient by automatically fetching the service's public key.
     *
     * @param baseUrl - The base URL of the Nilauth service.
     * @param payer - The payer instance used for handling subscription payments.
     * @returns Promise resolving to a fully configured NilauthClient instance.
     */
    static from(baseUrl: string, payer: Payer): Promise<NilauthClient>;
    /**
     * Fetch service metadata from a Nilauth server.
     *
     * Retrieves information including the service's public key, start time, and build information.
     *
     * @param serviceUrl - The base URL of the Nilauth service.
     * @returns Promise resolving to the service metadata.
     */
    static about(serviceUrl: string): Promise<NilauthAboutResponse>;
    /**
     * Perform a health check against a Nilauth server.
     *
     * Used to verify that the server is operational and responding to requests.
     *
     * @param serviceUrl - The base URL of the Nilauth service.
     * @returns Promise resolving to "OK" if the service is healthy.
     */
    static health(serviceUrl: string): Promise<NilauthHealthResponse>;
    /**
     * Queries a Nilauth server for any revoked tokens in the provided proof chain.
     *
     * This is a critical validation step in NUC verification. If any revocations are found,
     * the token should be considered invalid and rejected by any receiving entity.
     *
     * @param baseUrl - The base URL of the Nilauth service.
     * @param token - The token envelope containing the proof chain to validate.
     * @returns Promise resolving to a response containing any revoked tokens found.
     */
    static findRevocationsInProofChain(baseUrl: string, token: NucTokenEnvelope): Promise<LookupRevokedTokenResponse>;
    /**
     * Effect-based implementation for querying revocations in a proof chain.
     *
     * Provides the same functionality as `findRevocationsInProofChain` but returns
     * an Effect that can be composed with other operations.
     *
     * @param baseUrl - The base URL of the Nilauth service.
     * @param token - The token envelope containing the proof chain to validate.
     * @returns Effect resolving to a response with revoked tokens or failing with typed errors.
     */
    static findRevocationsInProofChainEffect(baseUrl: string, token: NucTokenEnvelope): Effect.Effect<LookupRevokedTokenResponse, ZodError | InvalidContentType | FetchError>;
    /**
     * Construct a NilauthClient directly from configuration options.
     *
     * For most use cases, prefer using the static `from()` method which automatically
     * fetches the service's public key.
     *
     * @param options - Client configuration including keypair, payer, and nilauth service info.
     */
    constructor(options: NilauthClientOptions);
    /**
     * The nilchain payer instance used for handling subscription payments.
     * Used internally during payment operations.
     */
    get payer(): Payer;
    /**
     * The Nilauth service's public key.
     * Used for verification and authentication.
     */
    get nilauthPublicKey(): string;
    /**
     * The Nilauth service's base URL.
     * All API endpoints are constructed relative to this URL.
     */
    get nilauthBaseUrl(): string;
    /**
     * Retrieve server metadata from the configured Nilauth service.
     *
     * Returns information including the service's public key, start time,
     * and build details.
     *
     * @returns Promise resolving to the service metadata.
     */
    about(): Promise<NilauthAboutResponse>;
    /**
     * Verify that the configured Nilauth service is operational.
     *
     * Performs a simple health check to confirm the server is responding.
     *
     * @returns Promise resolving to "OK" if the service is healthy.
     */
    health(): Promise<NilauthHealthResponse>;
    /**
     * Fetch the current subscription cost from the Nilauth service.
     *
     * Returns the cost in unils (Nilchain's token units).
     *
     * @param blindModule - The module for which the subscription cost is requested (e.g., "nilai" or "nildb").
     * @returns Promise resolving to the numeric subscription cost.
     */
    subscriptionCost(blindModule: BlindModule): Promise<SubscriptionCostResponse>;
    /**
     * Effect-based implementation for fetching the current subscription cost.
     *
     * Provides the same functionality as `subscriptionCost()` but returns an
     * Effect that can be composed with other operations.
     *
     * @param blindModule - The module for which the subscription cost is requested (e.g., "nilai" or "nildb").
     * @returns Effect resolving to the subscription cost or failing with typed errors.
     */
    subscriptionCostEffect(blindModule: BlindModule): Effect.Effect<SubscriptionCostResponse, ZodError | InvalidContentType | FetchError>;
    /**
     * Check the current subscription status with the Nilauth service.
     *
     * Returns information about whether the client is subscribed and if so,
     * the subscription's expiration and renewal details.
     *
     * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.
     * @param blindModule - The module for which the subscription status is checked (e.g., "nilai" or "nildb").
     * @returns Promise resolving to the subscription status.
     */
    subscriptionStatus(publicKey: Hex, blindModule: BlindModule): Promise<SubscriptionStatusResponse>;
    /**
     * Effect-based implementation for checking subscription status.
     *
     * Returns `{ subscribed: false, details: null }` if not subscribed, or
     * `{ subscribed: true, details: {...} }` with expiration details if subscribed.
     *
     * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.
     * @param blindModule - The module for which the subscription status is checked (e.g., "nilai" or "nildb").
     * @returns Effect resolving to the subscription status or failing with typed errors.
     */
    subscriptionStatusEffect(publicKey: Hex, blindModule: BlindModule): Effect.Effect<SubscriptionStatusResponse, ZodError | InvalidContentType | FetchError>;
    /**
     * Complete end-to-end payment flow for a Nilauth subscription.
     *
     * This method performs three steps:
     * 1. Fetches the current subscription cost
     * 2. Makes a payment transaction on Nilchain
     * 3. Validates the payment with the Nilauth service
     *
     * @returns Promise resolving when payment and validation succeed, or throws on failure.
     */
    payAndValidate(publicKey: string, blindModule: BlindModule): Promise<void>;
    /**
     * Create and submit a payment transaction for a subscription.
     *
     * Uses the configured payer to submit a transaction to Nilchain for the specified amount.
     *
     * @param amount - The payment amount in unils.
     * @param blindModule - The module for which the payment is made (e.g., "nilai" or "nildb").
     * @returns Effect resolving to the transaction hash and payload, or failing with a payment error.
     */
    payEffect(amount: number, blindModule: BlindModule): Effect.Effect<{
        txHash: string;
        payloadHex: Hex;
    }, PaymentTxFailed>;
    /**
     * Notify the Nilauth service about a completed payment transaction.
     *
     * After making a payment on Nilchain, this method validates the transaction with
     * the Nilauth service to activate the subscription. It automatically retries
     * if the transaction has not yet been committed to the blockchain.
     *
     * @param config - Configuration object containing:
     * - `publicKey`: The public key of the account for which to activate the subscription.
     * - `txHash`: The transaction hash of the payment made on Nilchain.
     * - `payloadHex`: The hex-encoded payload used in the payment transaction.
     * @returns Effect resolving to the validation response or failing with typed errors.
     */
    validatePaymentEffect(config: {
        publicKey: string;
        txHash: string;
        payloadHex: Hex;
    }): Effect.Effect<ValidatePaymentResponse, ZodError | InvalidContentType | FetchError>;
    /**
     * Request a new NUC token from the Nilauth service.
     *
     * Creates a fresh token that can be used for authentication and authorization
     * with Nilauth and compatible services.
     *
     * Requesting tokens can only be done if a subscription for the blind module is paid.
     *
     * @param keypair - The keypair used to sign the request.
     * @param blindModule - The module for which the token is requested (e.g., "nilai" or "nildb").
     * @returns Promise resolving to the created token response.
     */
    requestToken(keypair: Keypair, blindModule: BlindModule): Promise<CreateTokenResponse>;
    /**
     * Effect-based implementation for requesting a new NUC token.
     *
     * Provides the same functionality as `requestToken()` but returns an
     * Effect that can be composed with other operations.
     *
     * @param keypair - The keypair used to sign the request.
     * @param blindModule - The module for which the token is requested (e.g., "nilai" or "nildb").
     * @returns Effect resolving to the created token response or failing with typed errors.
     */
    requestTokenEffect(keypair: Keypair, blindModule: BlindModule): Effect.Effect<CreateTokenResponse, ZodError | InvalidContentType | FetchError>;
    /**
     * Revoke a previously issued NUC token.
     *
     * This invalidates the specified token by registering a revocation with the
     * Nilauth service. Any future verification of this token should fail.
     *
     * @param config - Configuration object containing:
     * - `keypair`: The keypair used to sign the revocation request.
     * - `authToken`: The NUC token envelope used for authentication.
     * - `tokenToRevoke`: The NUC token envelope to be revoked.
     * @returns Promise resolving when revocation is successfully registered.
     */
    revokeToken(config: {
        keypair: Keypair;
        authToken: NucTokenEnvelope;
        tokenToRevoke: NucTokenEnvelope;
    }): Promise<void>;
    /**
     * Effect-based implementation for submitting a token revocation.
     *
     * Sends a revocation invocation to the Nilauth service to invalidate
     * the specified token.
     *
     * @param revokeTokenInvocation - The serialized revocation invocation.
     * @returns Effect resolving when revocation succeeds or failing with typed errors.
     */
    revokeTokenEffect(revokeTokenInvocation: string): Effect.Effect<void, ZodError | InvalidContentType | FetchError>;
    /**
     * Asks the nilauth server to provide, if any, revoked tokens in the proof chain. If any revocations are returned
     * then any entity receiving the provided token should reject it.
     *
     * @param token - The envelope of the token to check.
     * @returns Promise resolving to the lookup response.
     */
    findRevocationsInProofChain(token: NucTokenEnvelope): Promise<LookupRevokedTokenResponse>;
}

declare global {
    interface Window extends Window {
    }
}
/**
 * Payer builder.
 */
declare class PayerBuilder {
    private _keypair?;
    private _chainUrl?;
    private _gasLimit;
    private _broadcastTimeoutMs;
    private _broadcastPollIntervalMs;
    keypair(keypair: Keypair): this;
    chainUrl(url: string): this;
    gasLimit(gasLimit: GasLimit): this;
    broadcastTimeoutMs(broadcastTimeoutMs: number): this;
    broadcastPollIntervalMs(broadcastPollIntervalMs: number): this;
    build(): Promise<Payer>;
}
declare class KeplrPayerBuilder {
    private _chainUrl?;
    private _chainId?;
    private _rpcEndpoint?;
    private _gasLimit;
    private _broadcastTimeoutMs;
    private _broadcastPollIntervalMs;
    chainUrl(url: string): this;
    chainId(chainId: string): this;
    rpcEndpoint(rpcEndpoint: string): this;
    gasLimit(gasLimit: GasLimit): this;
    broadcastTimeoutMs(broadcastTimeoutMs: number): this;
    broadcastPollIntervalMs(broadcastPollIntervalMs: number): this;
    build(): Promise<Payer>;
}

declare const CHAIN_TOO_LONG = "token chain is too long";
declare const COMMAND_NOT_ATTENUATED = "command is not an attenuation";
declare const DIFFERENT_SUBJECTS = "different subjects in chain";
declare const INVALID_AUDIENCE = "invalid audience";
declare const INVALID_SIGNATURES = "invalid signatures";
declare const ISSUER_AUDIENCE_MISMATCH = "issuer/audience mismatch";
declare const MISSING_PROOF = "proof is missing";
declare const NEED_DELEGATION = "token must be a delegation";
declare const NEED_INVOCATION = "token must be an invocation";
declare const NOT_BEFORE_BACKWARDS = "`not before` cannot move backwards";
declare const NOT_BEFORE_NOT_MET = "`not before` date not met";
declare const POLICY_NOT_MET = "policy not met";
declare const POLICY_TOO_DEEP = "policy is too deep";
declare const POLICY_TOO_WIDE = "policy is too wide";
declare const PROOFS_MUST_BE_DELEGATIONS = "proofs must be delegations";
declare const ROOT_KEY_SIGNATURE_MISSING = "root NUC is not signed by root keypair";
declare const SUBJECT_NOT_IN_CHAIN = "subject not in chain";
declare const TOKEN_EXPIRED = "token is expired";
declare const TOO_MANY_PROOFS = "up to one `prf` in a token is allowed";
declare const UNCHAINED_PROOFS = "extra proofs not part of chain provided";
declare class InvocationRequirement {
    audience: Did;
    constructor(audience: Did);
}
declare class DelegationRequirement {
    audience: Did;
    constructor(audience: Did);
}
type ValidationParametersConfig = {
    maxChainLength: number;
    maxPolicyWidth: number;
    maxPolicyDepth: number;
    tokenRequirements?: InvocationRequirement | DelegationRequirement;
};
declare class ValidationParameters {
    readonly config: ValidationParametersConfig;
    constructor(config?: Partial<ValidationParametersConfig>);
}
declare class NucTokenValidator {
    private readonly rootIssuers;
    timeProvider: () => Temporal.Instant;
    constructor(rootIssuers: Array<Did>, timeProvider?: () => Temporal.Instant);
    validate(envelope: NucTokenEnvelope, parameters: ValidationParameters, context?: Record<string, unknown>): void;
    validateProofs(token: NucToken, proofs: Array<NucToken>): void;
    static validateTokenChain(tokens: Array<NucToken>, parameters: ValidationParameters, now: Temporal.Instant): void;
    static validateRelationshipProperties(previous: NucToken, current: NucToken): void;
    static validateTemporalProperties(token: NucToken, currentTime: Temporal.Instant): void;
    static validatePoliciesProperties(policies: Array<Policy>, parameters: ValidationParameters): void;
    static validateToken(token: NucToken, proofs: Array<NucToken>, context: Record<string, unknown>, tokenRequirements?: InvocationRequirement | DelegationRequirement): void;
    static validateDelegationToken(token: NucToken, tokenRequirements?: InvocationRequirement | DelegationRequirement): void;
    static validateInvocationToken(token: NucToken, proofs: Array<NucToken>, context: Record<string, unknown>, tokenRequirements?: InvocationRequirement | DelegationRequirement): void;
    static validatePolicyEvaluates(proof: NucToken, tokenJson: Record<string, unknown>, context: Record<string, unknown>): void;
    static sortProofs(hash: Uint8Array, proofs: Array<DecodedNucToken>): Array<NucToken>;
}
declare class PolicyTreeProperties {
    private properties;
    constructor(properties: {
        maxDepth: number;
        maxWidth: number;
    });
    get maxDepth(): number;
    set maxDepth(value: number);
    get maxWidth(): number;
    set maxWidth(value: number);
    static fromPolicy(rootPolicy: Policy): PolicyTreeProperties;
}

export { And, AndSchema, AnyOf, AnyOfSchema, type BlindModule, BuildSchema, CHAIN_TOO_LONG, COMMAND_NOT_ATTENUATED, Command, CommandSchema, type ConnectorPolicy, ConnectorSchema, type CreateTokenResponse, CreateTokenResponseSchema, DIFFERENT_SUBJECTS, DecodedNucToken, DecodedNucTokenSchema, DelegationBody, DelegationBodySchema, DelegationRequirement, Did, DidSchema, type DidString, EpochSeconds, Equals, EqualsSchema, type GasLimit, GasLimitSchema, HeaderSchema, type Hex, HexSchema, INVALID_AUDIENCE, INVALID_SIGNATURES, ISSUER_AUDIENCE_MISMATCH, InvocationBody, InvocationBodySchema, InvocationRequirement, KeplrPayerBuilder, Keypair, type LookupRevokedTokenResponse, LookupRevokedTokenResponseSchema, MISSING_PROOF, NEED_DELEGATION, NEED_INVOCATION, NOT_BEFORE_BACKWARDS, NOT_BEFORE_NOT_MET, NilChainAddress, NilChainAddressPrefix, NilChainProtobufTypeUrl, NilToken, type NilauthAboutResponse, NilauthAboutResponseSchema, NilauthClient, type NilauthClientOptions, type NilauthHealthResponse, NilauthHealthResponseSchema, Not, NotEquals, NotEqualsSchema, NotSchema, NucToken, NucTokenBuilder, type NucTokenData, NucTokenDataSchema, NucTokenEnvelope, NucTokenEnvelopeSchema, NucTokenSchema, NucTokenValidator, OfflineSignerSchema, type OperatorPolicy, OperatorSchema, Or, OrSchema, POLICY_NOT_MET, POLICY_TOO_DEEP, POLICY_TOO_WIDE, PROOFS_MUST_BE_DELEGATIONS, Payer, PayerBuilder, type PayerConfig, PayerConfigSchema, type Policy, PolicySchema, PolicyTreeProperties, PrivateKeyBase16, type PublicKey, PublicKeySchema, REVOKE_COMMAND, ROOT_KEY_SIGNATURE_MISSING, type RevokedToken, RevokedTokenSchema, SUBJECT_NOT_IN_CHAIN, Selector, SelectorSchema, type SelectorTarget, type SignedRequest, type SubscriptionCostResponse, SubscriptionCostResponseSchema, type SubscriptionDetails, SubscriptionDetailsSchema, type SubscriptionStatusResponse, SubscriptionStatusResponseSchema, TOKEN_EXPIRED, TOO_MANY_PROOFS, TxHash, UNCHAINED_PROOFS, type ValidatePaymentResponse, ValidatePaymentResponseSchema, ValidationParameters, type ValidationParametersConfig, assertType, base64UrlDecode, base64UrlDecodeToBytes, base64UrlEncode, createSignedRequest, extractResponseJson, extractResponseText, generateNonce, pairwise, parseEpochSeconds, parseWithZodSchema, randomBytes, toHex, unwrapEffect };
