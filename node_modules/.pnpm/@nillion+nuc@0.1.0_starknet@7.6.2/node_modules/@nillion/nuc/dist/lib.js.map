{"version":3,"sources":["../src/builder.ts","../src/keypair.ts","../src/token.ts","../src/policy.ts","../src/selector.ts","../src/utils.ts","../src/errors.ts","../src/envelope.ts","../src/nilauth/client.ts","../src/logger.ts","../src/nilauth/retryable-fetch.ts","../src/nilauth/types.ts","../src/nilauth/urls.ts","../src/payer/builder.ts","../src/payer/client.ts","../src/gen-proto/nillion/meta/v1/tx_pb.ts","../src/payer/types.ts","../src/payer/grpc-compat.ts","../src/validate.ts"],"sourcesContent":["import { bytesToHex } from \"@noble/hashes/utils\";\nimport { Temporal } from \"temporal-polyfill\";\nimport type { NucTokenEnvelope } from \"#/envelope\";\nimport { Keypair } from \"#/keypair\";\nimport type { Policy } from \"#/policy\";\nimport {\n  type Command,\n  DelegationBody,\n  Did,\n  InvocationBody,\n  NucToken,\n  NucTokenDataSchema,\n} from \"#/token\";\nimport {\n  base64UrlEncode,\n  type Hex,\n  parseEpochSeconds,\n  randomBytes,\n} from \"#/utils\";\n\nconst DEFAULT_NONCE_LENGTH = 16;\n\n/**\n * Builder for a NUC token.\n */\nexport class NucTokenBuilder {\n  private _audience?: Did;\n  private _subject?: Did;\n  private _notBefore?: Temporal.Instant;\n  private _expiresAt?: Temporal.Instant;\n  private _command?: Command;\n  private _meta?: Record<string, unknown>;\n  private _nonce?: Hex;\n  private _proof?: NucTokenEnvelope;\n\n  private constructor(private _body: DelegationBody | InvocationBody) {}\n\n  /**\n   * Create a new token builder for a delegation token.\n   * @param policies The policies to use in the delegation.\n   */\n  static delegation(policies: Array<Policy>): NucTokenBuilder {\n    return new NucTokenBuilder(new DelegationBody(policies));\n  }\n\n  /**\n   * Creates a new token builder for an invocation.\n   * @param args The arguments to use in the invocation.\n   */\n  static invocation(args: Record<string, unknown>): NucTokenBuilder {\n    return new NucTokenBuilder(new InvocationBody(args));\n  }\n\n  /**\n   * Create a NUC token builder that pulls basic properties from a given NUC token.\n   *\n   * This pulls the following properties from the given envelope:\n   *\n   *  * command\n   *  * subject\n   *\n   * @param envelope The envelope to extend.\n   */\n  static extending(envelope: NucTokenEnvelope): NucTokenBuilder {\n    const token = envelope.token;\n    if (token.token.body instanceof InvocationBody) {\n      throw Error(\"cannot extend an invocation\");\n    }\n    return new NucTokenBuilder(token.token.body)\n      .proof(envelope)\n      .command(token.token.command)\n      .subject(token.token.subject);\n  }\n\n  /**\n   * Set the audience for the token to be built.\n   *\n   * The audience must be the entity this token is going to be sent to.\n   *\n   * @param audience The audience of the token.\n   */\n  audience(audience: Did): NucTokenBuilder {\n    this._audience = audience;\n    return this;\n  }\n\n  /**\n   * Set the body for the token being built.\n   *\n   * @param body The body for the token.\n   */\n  body(body: DelegationBody | InvocationBody): NucTokenBuilder {\n    this._body = body;\n    return this;\n  }\n\n  /**\n   * Set the subject for the token to be built.\n   *\n   * @param subject The subject of the token.\n   */\n  subject(subject: Did): NucTokenBuilder {\n    this._subject = subject;\n    return this;\n  }\n\n  /**\n   * Set the token's `not before` instant.\n   *\n   * @param epoch The Unix timestamp (in seconds) at which the token becomes valid.\n   * @throws Error if the value is not a valid epoch timestamp.\n   */\n  notBefore(epoch: number): NucTokenBuilder {\n    const notBeforeInSeconds = parseEpochSeconds(epoch);\n    this._notBefore = Temporal.Instant.fromEpochMilliseconds(\n      notBeforeInSeconds * 1000,\n    );\n    return this;\n  }\n\n  /**\n   * Set the token's `expires at` instant.\n   *\n   * @param epoch The Unix timestamp (in seconds) at which the token expires.\n   * @throws Error if the value is not a valid epoch timestamp.\n   */\n  expiresAt(epoch: number): NucTokenBuilder {\n    const expiresAtInSeconds = parseEpochSeconds(epoch);\n    this._expiresAt = Temporal.Instant.fromEpochMilliseconds(\n      expiresAtInSeconds * 1000,\n    );\n    return this;\n  }\n\n  /**\n   * Set the command for the token to be built.\n   *\n   * @param command The command for the token to be built.\n   */\n  command(command: Command): NucTokenBuilder {\n    this._command = command;\n    return this;\n  }\n\n  /**\n   * Set the metadata for the token to be built.\n   *\n   * @param meta The metadata for the built token.\n   */\n  meta(meta: Record<string, unknown>): NucTokenBuilder {\n    this._meta = meta;\n    return this;\n  }\n\n  /**\n   * Set the nonce for the token to be built.\n   *\n   * @param nonce The nonce to be set.\n   *\n   * The nonce doesn't have to be explicitly set and it will default to a random 16 bytes long bytestring if not set.\n   */\n  nonce(nonce: Hex): NucTokenBuilder {\n    this._nonce = nonce;\n    return this;\n  }\n\n  /**\n   * Set the proof for the token to be built.\n   *\n   * It's recommended to call :meth:`NucTokenBuilder.extending` which also takes care of pulling other important fields.\n   *\n   * @param proof The token to be used as proof.\n   */\n  proof(proof: NucTokenEnvelope): NucTokenBuilder {\n    this._proof = proof;\n    return this;\n  }\n\n  /**\n   * Build the token, signing it using the given private key.\n   *\n   * @param key The key to use to sing the token.\n   */\n  build(key: Uint8Array): string {\n    const keypair = new Keypair(key);\n    const proof = this._proof;\n    if (proof) {\n      proof.validateSignatures();\n    }\n    const data = NucTokenDataSchema.parse({\n      body: this._body,\n      issuer: new Did(keypair.publicKey()),\n      audience: this._audience,\n      subject: this._subject,\n      notBefore: this._notBefore,\n      expiresAt: this._expiresAt,\n      command: this._command,\n      meta: this._meta,\n      nonce: this._nonce\n        ? this._nonce\n        : bytesToHex(randomBytes(DEFAULT_NONCE_LENGTH)),\n      proofs: proof ? [proof.token.computeHash()] : [],\n    });\n    let token = base64UrlEncode(new NucToken(data).toString());\n    const header = base64UrlEncode('{\"alg\":\"ES256K\"}');\n    token = `${header}.${token}`;\n\n    const signature = keypair.sign(token);\n    token = `${token}.${base64UrlEncode(signature)}`;\n    if (this._proof) {\n      const allProofs = [this._proof.token, ...this._proof.proofs];\n      token = `${token}/${allProofs.map((proof) => proof.serialize()).join(\"/\")}`;\n    }\n    return token;\n  }\n}\n","import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { Did, type DidString } from \"#/token\";\n\ntype KeyFormat = \"bytes\" | \"hex\";\n\n/**\n * Represents a secp256k1 elliptic curve key pair with secure key handling\n */\nexport class Keypair {\n  readonly #privateKey: Uint8Array;\n  readonly #publicKey: Uint8Array;\n\n  /**\n   * Creates a Keypair instance from a valid 32-byte private key\n   * @param privateKey - The private key as raw bytes\n   */\n  constructor(privateKey: Uint8Array) {\n    this.#privateKey = privateKey;\n    this.#publicKey = secp256k1.getPublicKey(privateKey);\n  }\n\n  /**\n   * Get private key in specified format\n   * @param format - Output encoding (default: bytes in an Uint8Array)\n   * @returns Private key in requested format\n   */\n  privateKey(format?: \"bytes\"): Uint8Array;\n  privateKey(format: \"hex\"): string;\n  privateKey(format?: KeyFormat): Uint8Array | string {\n    return format === \"hex\"\n      ? bytesToHex(this.#privateKey)\n      : new Uint8Array(this.#privateKey);\n  }\n\n  /**\n   * Get public key in specified format\n   * @param format - Output encoding (default: bytes in an Uint8Array)\n   * @returns Public key in requested format\n   */\n  publicKey(format?: \"bytes\"): Uint8Array;\n  publicKey(format: \"hex\"): string;\n  publicKey(format?: KeyFormat): Uint8Array | string {\n    return format === \"hex\"\n      ? bytesToHex(this.#publicKey)\n      : new Uint8Array(this.#publicKey);\n  }\n\n  /**\n   * Returns true if this keypair matches the provided public key\n   */\n  matchesPublicKey(pk: Uint8Array | string): boolean {\n    const compareKeyHex = typeof pk === \"string\" ? pk : bytesToHex(pk);\n    return this.publicKey(\"hex\") === compareKeyHex;\n  }\n\n  /**\n   * Returns a Did\n   */\n  toDid(): Did {\n    return new Did(this.#publicKey);\n  }\n\n  /**\n   * Returns a stringified Did, e.g., did:nil:<public_key_as_hex>\n   */\n  toDidString(): DidString {\n    return this.toDid().toString();\n  }\n\n  /**\n   * Creates a Keypair from a private key\n   * @param privateKey - The private key as hex string or raw bytes\n   * @returns New Keypair instance\n   */\n  static from(privateKey: Uint8Array): Keypair;\n  static from(privateKey: string): Keypair;\n  static from(privateKey: string | Uint8Array): Keypair {\n    const bytes =\n      typeof privateKey === \"string\" ? hexToBytes(privateKey) : privateKey;\n\n    return new Keypair(bytes);\n  }\n\n  /**\n   * Generates a new cryptographically secure random key pair\n   * @returns A new Keypair instance\n   */\n  static generate(): Keypair {\n    return new Keypair(secp256k1.utils.randomPrivateKey());\n  }\n\n  /**\n   * Signs a message\n   * @param msg Message to sign\n   * @param signatureFormat Result format. Only \"hex\" and \"bytes\" are valid (default: bytes in an Uint8Array).\n   * @return The signature in raw bytes or hex string, depending on the given format.\n   */\n  sign(msg: string, signatureFormat?: \"bytes\"): Uint8Array;\n  sign(msg: string, signatureFormat: \"hex\"): string;\n  sign(msg: string, signatureFormat?: \"bytes\" | \"hex\"): Uint8Array | string {\n    const msgBytes = new TextEncoder().encode(msg);\n    const signature = secp256k1.sign(msgBytes, this.privateKey(), {\n      prehash: true,\n    });\n    return signatureFormat === \"hex\"\n      ? signature.toCompactHex()\n      : signature.toCompactRawBytes();\n  }\n}\n","import { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { dequal } from \"dequal\";\nimport { Temporal } from \"temporal-polyfill\";\nimport { z } from \"zod\";\nimport { type Policy, PolicySchema } from \"#/policy\";\nimport { EpochSeconds, type Hex, HexSchema } from \"#/utils\";\n\nconst DID_EXPRESSION = /^did:nil:([a-zA-Z0-9]{66})$/;\n\nexport const DidSchema = z\n  .string()\n  .transform((did) => DID_EXPRESSION.exec(did))\n  .refine((match) => match !== null, \"invalid DID\")\n  .transform((match) => Did.fromHex(match[1]));\n\nexport type DidString = `did:nil:${string}`;\n\n/**\n * A class representing a Decentralized Identifier (DID).\n */\nexport class Did {\n  /**\n   *\n   * Creates a new DID for the given public key.\n   * @param publicKey Public key in bytes format.\n   */\n  constructor(public readonly publicKey: Uint8Array) {}\n\n  /**\n   * Convert this DID into a string.\n   */\n  toString(): DidString {\n    return `did:nil:${this.publicKeyAsHex()}`;\n  }\n\n  /**\n   * Get the public which this DID represents.\n   */\n  publicKeyAsHex(): string {\n    return bytesToHex(this.publicKey);\n  }\n\n  /**\n   * Check if this and another DID are equals.\n   * @param other The other DID which will be used for the equality operation.\n   */\n  isEqual(other: Did): boolean {\n    return bytesToHex(this.publicKey) === bytesToHex(other.publicKey);\n  }\n\n  /**\n   * Creates a new DID for the given public key.\n   * @param hex Public key in hex format.\n   */\n  static fromHex(hex: Hex): Did {\n    return new Did(hexToBytes(hex));\n  }\n}\n\nexport const CommandSchema = z\n  .string()\n  .startsWith(\"/\", \"command must start with '/'\")\n  .transform((selector) => {\n    const s = selector.slice(1);\n    if (!s) return [];\n    return s.split(\"/\");\n  })\n  .refine((labels) => labels.every(Boolean), \"empty command\")\n  .transform((segments) => {\n    return new Command(segments);\n  });\n\n/**\n * A command to be invoked.\n */\nexport class Command {\n  constructor(public readonly segments: Array<string>) {}\n\n  /**\n   * Check if this command is an attenuation of another one.\n   * @param other The command for which this command is attenuation.\n   */\n  isAttenuationOf(other: Command): boolean {\n    return (\n      this.segments.length >= other.segments.length &&\n      dequal(other.segments, this.segments.slice(0, other.segments.length))\n    );\n  }\n\n  /**\n   * Convert this command into a string.\n   */\n  toString(): string {\n    return `/${this.segments.join(\"/\")}`;\n  }\n}\nexport const REVOKE_COMMAND = new Command([\"nuc\", \"revoke\"]);\n\nexport const InvocationBodySchema = z\n  .record(z.string(), z.unknown())\n  .transform((args) => new InvocationBody(args));\n\n/**\n * Body of an invocation token.\n */\nexport class InvocationBody {\n  constructor(public readonly args: Record<string, unknown>) {}\n}\n\nexport const DelegationBodySchema = z\n  .array(PolicySchema)\n  .transform((body) => new DelegationBody(body as Array<Policy>));\n\n/**\n * Body of a delegation token.\n */\nexport class DelegationBody {\n  constructor(public readonly policies: Array<Policy>) {}\n}\n\nexport const NucTokenSchema = z\n  .object({\n    iss: DidSchema,\n    aud: DidSchema,\n    sub: DidSchema,\n    nbf: EpochSeconds.optional(),\n    exp: EpochSeconds.optional(),\n    cmd: CommandSchema,\n    args: InvocationBodySchema.optional(),\n    pol: DelegationBodySchema.optional(),\n    meta: z.record(z.string(), z.unknown()).optional(),\n    nonce: HexSchema,\n    prf: z.array(z.string()).default([]),\n  })\n  .transform((token) => {\n    return new NucToken({\n      issuer: token.iss,\n      audience: token.aud,\n      subject: token.sub,\n      command: token.cmd,\n      body: tokenBody(token.args, token.pol),\n      nonce: token.nonce,\n      proofs: token.prf.map((prf) => hexToBytes(prf)),\n      notBefore: token.nbf\n        ? Temporal.Instant.fromEpochMilliseconds(token.nbf * 1000)\n        : undefined,\n      expiresAt: token.exp\n        ? Temporal.Instant.fromEpochMilliseconds(token.exp * 1000)\n        : undefined,\n      meta: token.meta,\n    });\n  });\n\nfunction tokenBody(\n  args: InvocationBody | undefined,\n  pol: DelegationBody | undefined,\n): InvocationBody | DelegationBody {\n  if (args !== undefined && pol !== undefined)\n    throw Error(\"one of 'args' and 'pol' must be set\");\n  if (args !== undefined) return args;\n  if (pol !== undefined) return pol;\n  throw Error(\"'args' and 'pol' can't both be set\");\n}\n\nexport const NucTokenDataSchema = z.object({\n  issuer: z.instanceof(Did),\n  audience: z.instanceof(Did),\n  subject: z.instanceof(Did),\n  notBefore: z.instanceof(Temporal.Instant).optional(),\n  expiresAt: z.instanceof(Temporal.Instant).optional(),\n  command: z.instanceof(Command),\n  body: z.union([z.instanceof(DelegationBody), z.instanceof(InvocationBody)]),\n  meta: z.record(z.string(), z.unknown()).optional(),\n  nonce: HexSchema,\n  proofs: z.array(z.instanceof(Uint8Array)),\n});\n\nexport type NucTokenData = z.infer<typeof NucTokenDataSchema>;\n\n/**\n * A class representing a NUC token.\n */\nexport class NucToken {\n  constructor(private readonly _data: NucTokenData) {}\n\n  get issuer(): Did {\n    return this._data.issuer;\n  }\n\n  get audience(): Did {\n    return this._data.audience;\n  }\n\n  get subject(): Did {\n    return this._data.subject;\n  }\n\n  get command(): Command {\n    return this._data.command;\n  }\n\n  get body(): InvocationBody | DelegationBody {\n    return this._data.body;\n  }\n\n  get nonce(): Hex {\n    return this._data.nonce;\n  }\n\n  get proofs(): Array<Uint8Array> {\n    return this._data.proofs ? this._data.proofs : [];\n  }\n\n  get notBefore(): Temporal.Instant | undefined {\n    return this._data.notBefore;\n  }\n\n  get expiresAt(): Temporal.Instant | undefined {\n    return this._data.expiresAt;\n  }\n\n  get meta(): Record<string, unknown> | undefined {\n    return this._data.meta;\n  }\n\n  /**\n   * Convert this token into JSON.\n   */\n  toJson(): Record<string, unknown> {\n    return {\n      iss: this.issuer.toString(),\n      aud: this.audience.toString(),\n      sub: this.subject.toString(),\n      nbf: this.notBefore\n        ? Math.floor(this.notBefore.epochMilliseconds / 1000)\n        : undefined,\n      exp: this.expiresAt\n        ? Math.floor(this.expiresAt.epochMilliseconds / 1000)\n        : undefined,\n      cmd: this.command.toString(),\n      args: this.body instanceof InvocationBody ? this.body.args : undefined,\n      pol:\n        this.body instanceof DelegationBody\n          ? this.body.policies.map((policy) => policy.serialize())\n          : undefined,\n      meta: this.meta,\n      nonce: this.nonce,\n      prf:\n        this.proofs && this.proofs.length > 0\n          ? this.proofs.map((proof) => bytesToHex(proof))\n          : undefined,\n    };\n  }\n\n  /**\n   * Convert this command into a string.\n   */\n  toString(): string {\n    return JSON.stringify(this.toJson());\n  }\n}\n","import { dequal } from \"dequal\";\nimport { z } from \"zod\";\nimport { type Selector, SelectorSchema } from \"#/selector\";\n\n/**\n * A policy that restricts how a NUC can be used.\n */\nexport interface Policy {\n  /**\n   * Checks whether this policy matches a value.\n   * @param record Value against the policy is matched.\n   * @param context Application context against the policy is matched.\n   */\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean;\n\n  /**\n   *  Serialize the policy into an array of anything.\n   */\n  serialize(): Array<unknown>;\n\n  /**\n   * Serialize the policy into a string.\n   */\n  toString(): string;\n}\n\n/**\n * A policy that applies a selector on the NUC token and applies an operator to it.\n */\nexport interface OperatorPolicy extends Policy {}\n\nexport const EqualsSchema = z\n  .tuple([z.literal(\"==\"), SelectorSchema, z.unknown()])\n  .transform((operator) => new Equals(operator[1], operator[2]));\n\n/**\n * An operator that checks for equality.\n */\nexport class Equals implements OperatorPolicy {\n  constructor(\n    private readonly selector: Selector,\n    private readonly value: unknown,\n  ) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    return dequal(this.selector.apply(record, context), this.value);\n  }\n\n  serialize(): Array<unknown> {\n    return [\"==\", this.selector.toString(), this.value];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const NotEqualsSchema = z\n  .tuple([z.literal(\"!=\"), SelectorSchema, z.unknown()])\n  .transform((operator) => new NotEquals(operator[1], operator[2]));\n\n/**\n * An operator that checks for inequality.\n */\nexport class NotEquals implements OperatorPolicy {\n  constructor(\n    private readonly selector: Selector,\n    private readonly value: unknown,\n  ) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    return !dequal(this.selector.apply(record, context), this.value);\n  }\n\n  serialize(): Array<unknown> {\n    return [\"!=\", this.selector.toString(), this.value];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const AnyOfSchema = z\n  .tuple([z.literal(\"anyOf\"), SelectorSchema, z.array(z.unknown())])\n  .transform((operator) => new AnyOf(operator[1], operator[2]));\n\n/**\n * An operator that checks that a value is within a list of values.\n */\nexport class AnyOf implements OperatorPolicy {\n  constructor(\n    private readonly selector: Selector,\n    public readonly options: Array<unknown>,\n  ) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    const value = this.selector.apply(record, context);\n    return Array.from(this.options).some((option) => dequal(value, option));\n  }\n\n  serialize(): Array<unknown> {\n    return [\"anyOf\", this.selector.toString(), this.options];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const OperatorSchema = z.union([\n  EqualsSchema,\n  NotEqualsSchema,\n  AnyOfSchema,\n]);\n\n/**\n * Represents a connector of policies.\n */\nexport interface ConnectorPolicy extends Policy {}\n\nexport const AndSchema = z\n  .lazy(() => z.tuple([z.literal(\"and\"), z.array(PolicySchema)]))\n  .transform(\n    (connector) => new And(connector[1].map((policy) => policy as Policy)),\n  );\n\n/**\n * A connector that checks that a sequence of policies is valid.\n */\nexport class And implements ConnectorPolicy {\n  constructor(public readonly conditions: Array<Policy>) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    const conditions = this.conditions;\n    return (\n      conditions &&\n      conditions.length > 0 &&\n      conditions.every((condition) => condition.evaluate(record, context))\n    );\n  }\n\n  serialize(): Array<unknown> {\n    return [\n      \"and\",\n      ...this.conditions.map((condition) => condition.serialize()),\n    ];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const OrSchema = z\n  .lazy(() => z.tuple([z.literal(\"or\"), z.array(PolicySchema)]))\n  .transform(\n    (connector) => new Or(connector[1].map((policy) => policy as Policy)),\n  );\n\n/**\n * A connector that checks that at least policy in a sequence is valid.\n */\nexport class Or implements ConnectorPolicy {\n  constructor(public readonly conditions: Array<Policy>) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    return this.conditions.some((condition) =>\n      condition.evaluate(record, context),\n    );\n  }\n\n  serialize(): Array<unknown> {\n    return [\"or\", ...this.conditions.map((condition) => condition.serialize())];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const NotSchema = z\n  .lazy(() => z.tuple([z.literal(\"not\"), PolicySchema]))\n  .transform((connector) => new Not(connector[1] as Policy));\n\n/**\n * A connector that checks that at a policy is not valid.\n */\nexport class Not implements ConnectorPolicy {\n  constructor(public readonly condition: Policy) {}\n\n  evaluate(\n    record: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): boolean {\n    return !this.condition.evaluate(record, context);\n  }\n\n  serialize(): Array<unknown> {\n    return [\"not\", this.condition.serialize()];\n  }\n\n  toString(): string {\n    return JSON.stringify(this.serialize());\n  }\n}\n\nexport const ConnectorSchema = z.lazy(() =>\n  z.union([AndSchema, OrSchema, NotSchema]),\n);\n\nexport const PolicySchema: z.ZodType<unknown> = z.lazy(() =>\n  z.union([ConnectorSchema, OperatorSchema]),\n);\n","import { z } from \"zod\";\n\nconst ALPHABET_LABEL = /[a-zA-Z0-9_-]+/;\n\nexport type SelectorTarget = \"token\" | \"context\";\n\nexport const SelectorSchema = z\n  .string()\n  .transform((selector) =>\n    selector.startsWith(\"$\")\n      ? { selector: selector.slice(1), target: \"context\" as SelectorTarget }\n      : { selector, target: \"token\" as SelectorTarget },\n  )\n  .refine(\n    ({ selector }) => selector.startsWith(\".\"),\n    \"selector must start with '.' or '$'\",\n  )\n  .transform(({ selector, target }) => {\n    const s = selector.slice(1);\n    const labels = s ? s.split(\".\") : [];\n    return { labels, target };\n  })\n  .refine(({ labels }) => labels.every(Boolean), \"empty attribute\")\n  .refine(\n    ({ labels, target }) =>\n      (target === \"context\" && labels.length > 0) || target === \"token\",\n  )\n  .refine(\n    ({ labels }) => labels.every((label) => ALPHABET_LABEL.test(label)),\n    \"invalid attribute character\",\n  )\n  .transform(({ labels, target }) => new Selector(labels, target));\n\n/**\n * A selector that specifies a path within a JSON object to be matched.\n */\nexport class Selector {\n  constructor(\n    private readonly path: Array<string>,\n    private readonly target: SelectorTarget,\n  ) {}\n\n  /**\n   * Apply a selector on a value and return the matched value, if any.\n   * @param value The value that this selector could be applied to.\n   * @param context The context that this selector could be applied to.\n   */\n  apply<T = unknown>(value: T, context: Record<string, T>): T {\n    switch (this.target) {\n      case \"token\":\n        return Selector.applyOnValue(this.path, value) as T;\n      case \"context\": {\n        if (!this.path) return undefined as T;\n\n        return Selector.applyOnValue(this.path, context) as T;\n      }\n    }\n  }\n\n  static applyOnValue<T = unknown>(path: Array<string>, value: T): T {\n    let result = value;\n    for (const label of path) {\n      if (result !== null && typeof result === \"object\") {\n        const record = result as Record<string, unknown>;\n        if (label in record) {\n          result = record[label] as T;\n        } else {\n          return undefined as T;\n        }\n      } else {\n        return undefined as T;\n      }\n    }\n    return result;\n  }\n  /**\n   * Convert this selector into a string.\n   */\n  toString(): string {\n    const prefix = this.target === \"token\" ? \"\" : \"$\";\n    return `${prefix}.${this.path.join(\".\")}`;\n  }\n}\n","import { bytesToHex } from \"@noble/hashes/utils\";\nimport { base64url } from \"@scure/base\";\nimport { Effect as E, pipe } from \"effect\";\nimport { type Schema, type ZodError, z } from \"zod\";\nimport { InvalidContentType } from \"#/errors\";\nimport type { Keypair } from \"#/keypair\";\nimport type { SignedRequest } from \"#/nilauth/types\";\n\n/**\n * Zod schema for validating hexadecimal strings.\n */\nexport const HexSchema = z.string().regex(/^[a-fA-F0-9]+$/, \"invalid hex\");\n/** Type for a validated hexadecimal string. */\nexport type Hex = z.infer<typeof HexSchema>;\n\n/**\n * Epoch timestamp in seconds.\n **/\nexport const EpochSeconds = z.number().int().max(1e12);\n/**\n * Parses a value as an epoch timestamp in seconds.\n *\n * Validates that the value is an integer and does not exceed 1 trillion.\n * Throws a ZodError if validation fails.\n *\n * @param value - The value to parse as epoch seconds.\n * @returns The parsed epoch seconds as a number.\n * @throws Error if the value is not a valid epoch timestamp.\n * @example\n * parseEpochSeconds(1633036800) // Returns 1633036800\n * parseEpochSeconds(\"invalid\") // Throws Error\n */\nexport const parseEpochSeconds = (value: unknown): number => {\n  try {\n    return EpochSeconds.parse(value);\n  } catch (_e) {\n    throw new Error(`Invalid epoch: ${value}`);\n  }\n};\n\n/**\n * Converts a UTF-8 string to hexadecimal.\n *\n * The string is first encoded as UTF-8 bytes, then each byte is\n * converted to its hexadecimal representation.\n *\n * @param data - The UTF-8 string to convert.\n * @returns Hexadecimal representation of the UTF-8 encoded bytes.\n * @example\n * toHex(\"hello\") // Returns \"68656c6c6f\"\n * toHex(\"🔥\") // Returns \"f09f94a5\" (UTF-8 encoding of emoji)\n */\nexport function toHex(data: string): Hex {\n  const bytes = new TextEncoder().encode(data);\n  return bytesToHex(bytes);\n}\n\n/**\n * Encodes input as URL-safe base64 without padding.\n *\n * Converts strings to UTF-8 bytes before encoding. The resulting\n * base64url string has padding characters (=) removed for URL safety.\n *\n * @param input - String or byte array to encode.\n * @returns URL-safe base64 encoded string without padding.\n * @example\n * base64UrlEncode(\"hello\") // Returns \"aGVsbG8\"\n * base64UrlEncode(new Uint8Array([1, 2, 3])) // Returns \"AQID\"\n */\nexport function base64UrlEncode(input: string | Uint8Array): string {\n  const data =\n    typeof input === \"string\" ? new TextEncoder().encode(input) : input;\n  return base64url.encode(data).replace(/=+$/, \"\");\n}\n\n/**\n * Decodes a URL-safe base64 string into a UTF-8 string.\n *\n * Handles both padded and unpadded base64url strings. If input is a\n * Uint8Array, it's first decoded to a string before processing.\n *\n * @param input - Base64url string or bytes to decode.\n * @returns Decoded UTF-8 string.\n * @throws Error if the decoded bytes are not valid UTF-8.\n * @example\n * base64UrlDecode(\"aGVsbG8\") // Returns \"hello\"\n * base64UrlDecode(\"aGVsbG8=\") // Also returns \"hello\" (handles padding)\n */\nexport function base64UrlDecode(input: string | Uint8Array): string {\n  const inputStr =\n    typeof input === \"string\" ? input : new TextDecoder().decode(input);\n  const bytes = base64UrlDecodeToBytes(inputStr);\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Adds padding to a base64/base64url string if needed.\n *\n * Base64 strings must have a length that's a multiple of 4.\n * This function adds the appropriate number of '=' characters.\n *\n * @param input - Base64 string that may lack padding.\n * @returns Base64 string with proper padding.\n * @internal\n */\nfunction addBase64Padding(input: string): string {\n  const padding = (4 - (input.length % 4)) % 4;\n  return padding > 0 ? input + \"=\".repeat(padding) : input;\n}\n\n/**\n * Decodes a URL-safe base64 string into raw bytes.\n *\n * Automatically adds padding if needed before decoding. Useful when\n * you need the raw binary data rather than a UTF-8 string.\n *\n * @param input - Base64url string to decode.\n * @returns Decoded bytes as Uint8Array.\n * @example\n * base64UrlDecodeToBytes(\"AQID\") // Returns Uint8Array([1, 2, 3])\n */\nexport function base64UrlDecodeToBytes(input: string): Uint8Array {\n  // Add padding if needed (base64url often omits padding)\n  const padded = addBase64Padding(input);\n\n  // Decode using @scure/base which handles padding properly\n  return base64url.decode(padded);\n}\n\n/**\n * Generates consecutive pairs for a given array.\n * For example: [a, b, c] => [[a, b], [b, c]]\n * @param input - The input array.\n * @returns Array of consecutive pairs.\n */\nexport function pairwise<T>(input: Array<T>): Array<Array<T>> {\n  return input.slice(0, -1).map((item, index) => [item, input[index + 1]]);\n}\n\n/**\n * Generates cryptographically secure random bytes using Web Crypto API.\n * @param size - Number of random bytes to generate.\n * @returns Uint8Array of random bytes.\n * @throws Error if Web Crypto API is not available.\n */\nexport function randomBytes(size: number): Uint8Array {\n  const buffer = new Uint8Array(size);\n  globalThis.crypto.getRandomValues(buffer);\n  return buffer;\n}\n\n/**\n * Pipeable combinator to parse the result of an Effect using a Zod schema.\n *\n * @param schema - The Zod schema to use for parsing.\n * @returns A function that takes Effect<unknown, E> and returns Effect<T, E | ZodError>\n */\nexport function parseWithZodSchema<A, E>(\n  schema: Schema,\n): (effect: E.Effect<unknown, E>) => E.Effect<A, ZodError | E> {\n  return (effect) =>\n    effect.pipe(\n      E.flatMap((data) =>\n        E.try({\n          try: () => schema.parse(data),\n          catch: (e) => e as ZodError,\n        }),\n      ),\n    );\n}\n\n/**\n * Pipeable combinator to parse a Fetch Response as JSON.\n *\n * @returns A function that takes Effect<Response, E> and returns Effect<any, E | InvalidContentType>\n */\nexport function extractResponseJson<E>() {\n  return (\n    effect: E.Effect<globalThis.Response, E>,\n  ): E.Effect<unknown, E | InvalidContentType> =>\n    effect.pipe(\n      E.flatMap((response) =>\n        E.tryPromise({\n          try: () => response.json(),\n          catch: (cause) =>\n            new InvalidContentType({\n              actual: response.headers.get(\"content-type\"),\n              expected: \"plain/text\",\n              response,\n              cause: cause as Error,\n            }),\n        }),\n      ),\n    );\n}\n\n/**\n * Pipeable combinator to parse a Fetch Response as text.\n *\n * @returns A function that takes Effect<Response, E> and returns Effect<string, E | InvalidContentType>\n */\nexport function extractResponseText<E>() {\n  return (\n    effect: E.Effect<globalThis.Response, E>,\n  ): E.Effect<unknown, E | InvalidContentType> =>\n    effect.pipe(\n      E.flatMap((response) =>\n        E.tryPromise({\n          try: () => response.text(),\n          catch: (cause) =>\n            new InvalidContentType({\n              actual: response.headers.get(\"content-type\"),\n              expected: \"application/json\",\n              response,\n              cause: cause as Error,\n            }),\n        }),\n      ),\n    );\n}\n\n/**\n * Asserts the type of an Effect result at compile time.\n * Used for type narrowing in effectful pipelines.\n *\n * @returns A function that casts the Effect's output type.\n */\nexport function assertType<B>() {\n  return <A, E>(effect: E.Effect<A, E>): E.Effect<B, E> =>\n    effect as unknown as E.Effect<B, E>;\n}\n\n/**\n * Generates a random nonce as a hexadecimal string.\n * @returns Hexadecimal nonce string.\n */\nexport function generateNonce(): Hex {\n  const bytes = randomBytes(16);\n  return Array.from(bytes)\n    .map((b) => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n\n/**\n * Creates a signed request object from a payload and a keypair.\n *\n * @param payload - The payload to sign.\n * @param keypair - The keypair to use for signing.\n * @returns A SignedRequest object.\n */\nexport function createSignedRequest(\n  payload: Record<string, unknown>,\n  keypair: Keypair,\n): SignedRequest {\n  const stringifiedPayload = JSON.stringify(payload);\n  return {\n    public_key: keypair.publicKey(\"hex\"),\n    signature: keypair.sign(stringifiedPayload, \"hex\"),\n    payload: toHex(stringifiedPayload),\n  };\n}\n\n/**\n * Unwraps an Effect to a Promise, throwing on failure.\n * If the Effect fails, the error is thrown; otherwise, the value is returned.\n *\n * @param effect - The Effect to unwrap.\n * @returns Promise of the successful value, or throws the error.\n */\nexport async function unwrapEffect<A, E>(effect: E.Effect<A, E>): Promise<A> {\n  const result = await pipe(effect, E.either, E.runPromise);\n\n  if (result._tag === \"Right\") {\n    return result.right;\n  }\n  throw result.left;\n}\n","import { Data } from \"effect\";\nimport { z } from \"zod\";\n\n/**\n * Error thrown when a service cannot be contacted.\n * Used when network requests fail to establish a connection to the target.\n *\n * @property url - Target server URL.\n * @property cause - The original error that caused the failure (optional).\n */\nexport class NilauthUnreachable extends Data.TaggedError(\"NilauthUnreachable\")<{\n  url: string;\n  cause?: unknown;\n}> {\n  /**\n   * Returns a formatted string for logging.\n   */\n  override toString(): string {\n    const causeStr =\n      this.cause instanceof Error\n        ? this.cause.message\n        : this.cause\n          ? String(this.cause)\n          : \"unknown\";\n    return `${this._tag}: ${this.url}${causeStr ? ` cause=${causeStr}` : \"\"}`;\n  }\n}\n\n/**\n * Error thrown when the response content type does not match expectations.\n *\n * @property actual - The actual content type received.\n * @property expected - The expected content type.\n * @property response - The original Response object.\n * @property cause - The underlying error.\n */\nexport class InvalidContentType extends Data.TaggedError(\"InvalidContentType\")<{\n  actual: string | null;\n  expected: \"application/json\" | \"plain/text\";\n  response: globalThis.Response;\n  cause: Error;\n}> {\n  /**\n   * Returns a formatted string for logging.\n   */\n  override toString(): string {\n    return `${this._tag}: status=${this.response.status} url=${this.response.url} expected=${this.expected} actual=${this.actual} cause=${this.cause.message}`;\n  }\n}\n\n/**\n * Error thrown when a payment transaction fails.\n *\n * @property cause - The underlying error or reason for the failure.\n */\nexport class PaymentTxFailed extends Data.TaggedError(\"PaymentTxFailed\")<{\n  cause: unknown;\n}> {\n  /**\n   * Returns a formatted string for logging.\n   */\n  override toString(): string {\n    const causeStr =\n      this.cause instanceof Error\n        ? this.cause.message\n        : this.cause\n          ? String(this.cause)\n          : \"unknown\";\n    return `${this._tag}: cause=${causeStr}`;\n  }\n}\n\n/**\n * Zod schema and type for all known Nilauth error codes returned by the server.\n */\nexport const NilauthErrorCodeSchema = z.enum([\n  \"CANNOT_RENEW_YET\",\n  \"HASH_MISMATCH\",\n  \"INSUFFICIENT_PAYMENT\",\n  \"INTERNAL\",\n  \"INVALID_PUBLIC_KEY\",\n  \"MALFORMED_PAYLOAD\",\n  \"MALFORMED_TRANSACTION\",\n  \"NOT_SUBSCRIBED\",\n  \"PAYMENT_ALREADY_PROCESSED\",\n  \"TRANSACTION_LOOKUP\",\n  \"TRANSACTION_NOT_COMMITTED\",\n  \"UNKNOWN_PUBLIC_KEY\",\n]);\nexport type NilauthErrorCode = z.infer<typeof NilauthErrorCodeSchema>;\n\n/**\n * Zod schema for a structured error response from the Nilauth server.\n *\n * @property message - Human-readable error message.\n * @property code - Machine-readable error code.\n */\nexport const NilauthErrorResponseBodySchema = z.object({\n  message: z.string(),\n  error_code: NilauthErrorCodeSchema,\n});\n\nexport type NilauthErrorResponseBody = z.infer<\n  typeof NilauthErrorResponseBodySchema\n>;\n\n/**\n * Error thrown when the Nilauth server returns a structured error response.\n *\n * @property url - The request URL.\n * @property code - The error code returned by the server.\n * @property message - The error message returned by the server.\n * @property status - The HTTP status code.\n * @property cause - The underlying error or response body (optional).\n */\nexport class NilauthErrorResponse extends Data.TaggedError(\n  \"NilauthErrorResponse\",\n)<{\n  url: string;\n  code: NilauthErrorCode;\n  message: string;\n  status: number;\n  cause?: unknown;\n}> {\n  /**\n   * Returns a formatted string for logging.\n   */\n  override toString(): string {\n    const causeStr =\n      this.cause instanceof Error\n        ? this.cause.message\n        : this.cause\n          ? String(this.cause)\n          : \"\";\n    return `${this._tag}: [${this.code}] ${this.message} (url=${this.url}, status=${this.status})${causeStr ? ` cause=${causeStr}` : \"\"}`;\n  }\n}\n","import { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { toBytes } from \"@noble/hashes/utils\";\nimport { z } from \"zod\";\nimport { type NucToken, NucTokenSchema } from \"#/token\";\nimport {\n  base64UrlDecode,\n  base64UrlDecodeToBytes,\n  base64UrlEncode,\n} from \"#/utils\";\n\nconst INVALID_JWT_STRUCTURE = \"invalid JWT structure\";\nconst INVALID_JWT_HEADER = \"invalid JWT header\";\nconst SIGNATURE_VERIFICATION_FAILED = \"signature verification failed\";\n\nexport const NucTokenEnvelopeSchema = z\n  .string()\n  .transform((data) => data.split(\"/\"))\n  .refine((tokens) => tokens.every(Boolean), \"empty token\")\n  .transform((tokens) =>\n    tokens.map((token) => DecodedNucTokenSchema.parse(token)),\n  )\n  .refine((tokens) => tokens && tokens.length > 0)\n  .transform((tokens) => new NucTokenEnvelope(tokens[0], tokens.slice(1)));\n\n/**\n * A NUC token envelope, containing a parsed token along with all its proofs.\n */\nexport class NucTokenEnvelope {\n  constructor(\n    public readonly token: DecodedNucToken,\n    public readonly proofs: Array<DecodedNucToken>,\n  ) {}\n\n  /**\n   * Validate the signature in this envelope.\n   *\n   * This will raise an exception is the token or any of its proofs is not signed by its issuer.\n   */\n  validateSignatures() {\n    for (const token of [this.token, ...this.proofs]) {\n      token.validateSignature();\n    }\n  }\n\n  /**\n   * Serialize this envelope as a JWT-like string.\n   */\n  serialize(): string {\n    return `${[this.token, ...this.proofs].map((proof) => proof.serialize()).join(\"/\")}`;\n  }\n}\n\nexport const HeaderSchema = z.object({\n  alg: z.literal(\"ES256K\"),\n});\n\nexport const DecodedNucTokenSchema = z\n  .string()\n  .transform((data) => data.split(\".\"))\n  .refine((tokens) => tokens && tokens.length === 3, INVALID_JWT_STRUCTURE)\n  .refine(\n    ([rawHeader, _]) =>\n      HeaderSchema.parse(JSON.parse(base64UrlDecode(rawHeader))),\n    INVALID_JWT_HEADER,\n  )\n  .transform(([rawHeader, rawPayload, rawSignature]) => {\n    const token = NucTokenSchema.parse(JSON.parse(base64UrlDecode(rawPayload)));\n    const signature = base64UrlDecodeToBytes(rawSignature);\n    return new DecodedNucToken(rawHeader, rawPayload, signature, token);\n  });\n\n/**\n * A decoded NUC token.\n */\nexport class DecodedNucToken {\n  constructor(\n    public readonly rawHeader: string,\n    public readonly rawPayload: string,\n    public readonly signature: Uint8Array,\n    public readonly token: NucToken,\n  ) {}\n\n  /**\n   * Validate the signature in this token.\n   */\n  validateSignature() {\n    const msg = toBytes(`${this.rawHeader}.${this.rawPayload}`);\n    if (\n      !secp256k1.verify(this.signature, msg, this.token.issuer.publicKey, {\n        prehash: true,\n      })\n    ) {\n      throw new Error(SIGNATURE_VERIFICATION_FAILED);\n    }\n  }\n\n  /**\n   * Compute the hash for this token.\n   */\n  computeHash(): Uint8Array {\n    return sha256(this.serialize());\n  }\n\n  /**\n   * Serialize this token as a JWT.\n   */\n  serialize(): string {\n    return `${this.rawHeader}.${this.rawPayload}.${base64UrlEncode(this.signature)}`;\n  }\n}\n","import { sha256 } from \"@noble/hashes/sha256\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { Duration as D, Effect as E, pipe, Schedule as S } from \"effect\";\nimport { Temporal } from \"temporal-polyfill\";\nimport type { ZodError } from \"zod\";\nimport { NucTokenBuilder } from \"#/builder\";\nimport type { NucTokenEnvelope } from \"#/envelope\";\nimport {\n  type InvalidContentType,\n  NilauthErrorCodeSchema,\n  NilauthErrorResponse,\n  PaymentTxFailed,\n} from \"#/errors\";\nimport type { Keypair } from \"#/keypair\";\nimport { log } from \"#/logger\";\nimport {\n  type FetchError,\n  fetchWithTimeout,\n  type RequestOptions,\n} from \"#/nilauth/retryable-fetch\";\nimport {\n  type CreateTokenResponse,\n  CreateTokenResponseSchema,\n  type LookupRevokedTokenResponse,\n  LookupRevokedTokenResponseSchema,\n  type NilauthAboutResponse,\n  NilauthAboutResponseSchema,\n  type NilauthHealthResponse,\n  NilauthHealthResponseSchema,\n  type PublicKey,\n  type SubscriptionCostResponse,\n  SubscriptionCostResponseSchema,\n  type SubscriptionStatusResponse,\n  SubscriptionStatusResponseSchema,\n  type ValidatePaymentResponse,\n  ValidatePaymentResponseSchema,\n} from \"#/nilauth/types\";\nimport { NilauthUrl } from \"#/nilauth/urls\";\nimport type { Payer } from \"#/payer/client\";\nimport { Did, InvocationBody, REVOKE_COMMAND } from \"#/token\";\nimport {\n  assertType,\n  createSignedRequest,\n  extractResponseJson,\n  extractResponseText,\n  generateNonce,\n  type Hex,\n  parseWithZodSchema,\n  toHex,\n  unwrapEffect,\n} from \"#/utils\";\n\nexport type BlindModule = \"nilai\" | \"nildb\";\n\n/**\n * Options required to construct a NilauthClient.\n */\nexport type NilauthClientOptions = {\n  payer: Payer;\n  nilauth: {\n    baseUrl: string;\n    publicKey: PublicKey;\n  };\n};\n\n/**\n * Client for interacting with the Nilauth service.\n *\n * Provides methods for health checks, subscription management, payments,\n * token issuance, revocation, and proof chain validation.\n * Uses effectful, composable pipelines for all network operations with\n * consistent error handling and typed responses.\n */\nexport class NilauthClient {\n  /**\n   * Initialize a NilauthClient by automatically fetching the service's public key.\n   *\n   * @param baseUrl - The base URL of the Nilauth service.\n   * @param payer - The payer instance used for handling subscription payments.\n   * @returns Promise resolving to a fully configured NilauthClient instance.\n   */\n  static async from(baseUrl: string, payer: Payer): Promise<NilauthClient> {\n    const about = await NilauthClient.about(baseUrl);\n    return new NilauthClient({\n      payer,\n      nilauth: {\n        baseUrl,\n        publicKey: about.publicKey,\n      },\n    });\n  }\n\n  /**\n   * Fetch service metadata from a Nilauth server.\n   *\n   * Retrieves information including the service's public key, start time, and build information.\n   *\n   * @param serviceUrl - The base URL of the Nilauth service.\n   * @returns Promise resolving to the service metadata.\n   */\n  static about(serviceUrl: string): Promise<NilauthAboutResponse> {\n    const url = NilauthUrl.about(serviceUrl);\n    const request: RequestOptions = { url, method: \"GET\" };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(NilauthAboutResponseSchema),\n      assertType<NilauthAboutResponse>(),\n      logOutcome(request),\n      unwrapEffect,\n    );\n  }\n\n  /**\n   * Perform a health check against a Nilauth server.\n   *\n   * Used to verify that the server is operational and responding to requests.\n   *\n   * @param serviceUrl - The base URL of the Nilauth service.\n   * @returns Promise resolving to \"OK\" if the service is healthy.\n   */\n  static health(serviceUrl: string): Promise<NilauthHealthResponse> {\n    const url = NilauthUrl.health(serviceUrl);\n    const request: RequestOptions = { url, method: \"GET\" };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseText(),\n      parseWithZodSchema(NilauthHealthResponseSchema),\n      assertType<NilauthHealthResponse>(),\n      logOutcome(request),\n      unwrapEffect,\n    );\n  }\n\n  /**\n   * Queries a Nilauth server for any revoked tokens in the provided proof chain.\n   *\n   * This is a critical validation step in NUC verification. If any revocations are found,\n   * the token should be considered invalid and rejected by any receiving entity.\n   *\n   * @param baseUrl - The base URL of the Nilauth service.\n   * @param token - The token envelope containing the proof chain to validate.\n   * @returns Promise resolving to a response containing any revoked tokens found.\n   */\n  static findRevocationsInProofChain(\n    baseUrl: string,\n    token: NucTokenEnvelope,\n  ): Promise<LookupRevokedTokenResponse> {\n    return unwrapEffect(\n      NilauthClient.findRevocationsInProofChainEffect(baseUrl, token),\n    );\n  }\n\n  /**\n   * Effect-based implementation for querying revocations in a proof chain.\n   *\n   * Provides the same functionality as `findRevocationsInProofChain` but returns\n   * an Effect that can be composed with other operations.\n   *\n   * @param baseUrl - The base URL of the Nilauth service.\n   * @param token - The token envelope containing the proof chain to validate.\n   * @returns Effect resolving to a response with revoked tokens or failing with typed errors.\n   */\n  static findRevocationsInProofChainEffect(\n    baseUrl: string,\n    token: NucTokenEnvelope,\n  ): E.Effect<\n    LookupRevokedTokenResponse,\n    ZodError | InvalidContentType | FetchError\n  > {\n    const url = NilauthUrl.nucs.findRevocations(baseUrl);\n    const body = {\n      hashes: [token.token, ...token.proofs].map((token) =>\n        bytesToHex(token.computeHash()),\n      ),\n    };\n    const request: RequestOptions = {\n      url,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body,\n    };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(LookupRevokedTokenResponseSchema),\n      assertType<LookupRevokedTokenResponse>(),\n      logOutcome(request),\n    );\n  }\n\n  #options: NilauthClientOptions;\n\n  /**\n   * Construct a NilauthClient directly from configuration options.\n   *\n   * For most use cases, prefer using the static `from()` method which automatically\n   * fetches the service's public key.\n   *\n   * @param options - Client configuration including keypair, payer, and nilauth service info.\n   */\n  constructor(options: NilauthClientOptions) {\n    this.#options = options;\n  }\n\n  /**\n   * The nilchain payer instance used for handling subscription payments.\n   * Used internally during payment operations.\n   */\n  get payer(): Payer {\n    return this.#options.payer;\n  }\n\n  /**\n   * The Nilauth service's public key.\n   * Used for verification and authentication.\n   */\n  get nilauthPublicKey(): string {\n    return this.#options.nilauth.publicKey;\n  }\n\n  /**\n   * The Nilauth service's base URL.\n   * All API endpoints are constructed relative to this URL.\n   */\n  get nilauthBaseUrl(): string {\n    return this.#options.nilauth.baseUrl;\n  }\n\n  /**\n   * Retrieve server metadata from the configured Nilauth service.\n   *\n   * Returns information including the service's public key, start time,\n   * and build details.\n   *\n   * @returns Promise resolving to the service metadata.\n   */\n  // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: false positive\n  about(): Promise<NilauthAboutResponse> {\n    return NilauthClient.about(this.nilauthBaseUrl);\n  }\n\n  /**\n   * Verify that the configured Nilauth service is operational.\n   *\n   * Performs a simple health check to confirm the server is responding.\n   *\n   * @returns Promise resolving to \"OK\" if the service is healthy.\n   */\n  health(): Promise<NilauthHealthResponse> {\n    return NilauthClient.health(this.nilauthBaseUrl);\n  }\n\n  /**\n   * Fetch the current subscription cost from the Nilauth service.\n   *\n   * Returns the cost in unils (Nilchain's token units).\n   *\n   * @param blindModule - The module for which the subscription cost is requested (e.g., \"nilai\" or \"nildb\").\n   * @returns Promise resolving to the numeric subscription cost.\n   */\n  subscriptionCost(\n    blindModule: BlindModule,\n  ): Promise<SubscriptionCostResponse> {\n    return unwrapEffect(this.subscriptionCostEffect(blindModule));\n  }\n\n  /**\n   * Effect-based implementation for fetching the current subscription cost.\n   *\n   * Provides the same functionality as `subscriptionCost()` but returns an\n   * Effect that can be composed with other operations.\n   *\n   * @param blindModule - The module for which the subscription cost is requested (e.g., \"nilai\" or \"nildb\").\n   * @returns Effect resolving to the subscription cost or failing with typed errors.\n   */\n  subscriptionCostEffect(\n    blindModule: BlindModule,\n  ): E.Effect<\n    SubscriptionCostResponse,\n    ZodError | InvalidContentType | FetchError\n  > {\n    const url = NilauthUrl.payments.cost(this.nilauthBaseUrl, blindModule);\n    const request: RequestOptions = { url, method: \"GET\" };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(SubscriptionCostResponseSchema),\n      assertType<SubscriptionCostResponse>(),\n      logOutcome(request),\n    );\n  }\n\n  /**\n   * Check the current subscription status with the Nilauth service.\n   *\n   * Returns information about whether the client is subscribed and if so,\n   * the subscription's expiration and renewal details.\n   *\n   * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.\n   * @param blindModule - The module for which the subscription status is checked (e.g., \"nilai\" or \"nildb\").\n   * @returns Promise resolving to the subscription status.\n   */\n  subscriptionStatus(\n    publicKey: Hex,\n    blindModule: BlindModule,\n  ): Promise<SubscriptionStatusResponse> {\n    return unwrapEffect(this.subscriptionStatusEffect(publicKey, blindModule));\n  }\n\n  /**\n   * Effect-based implementation for checking subscription status.\n   *\n   * Returns `{ subscribed: false, details: null }` if not subscribed, or\n   * `{ subscribed: true, details: {...} }` with expiration details if subscribed.\n   *\n   * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.\n   * @param blindModule - The module for which the subscription status is checked (e.g., \"nilai\" or \"nildb\").\n   * @returns Effect resolving to the subscription status or failing with typed errors.\n   */\n  subscriptionStatusEffect(\n    publicKey: Hex,\n    blindModule: BlindModule,\n  ): E.Effect<\n    SubscriptionStatusResponse,\n    ZodError | InvalidContentType | FetchError\n  > {\n    const url = NilauthUrl.subscriptions.status(\n      this.nilauthBaseUrl,\n      publicKey,\n      blindModule,\n    );\n    const request: RequestOptions = {\n      url,\n      method: \"GET\",\n      headers: { \"Content-Type\": \"application/json\" },\n    };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(SubscriptionStatusResponseSchema),\n      E.catchTag(\"NilauthErrorResponse\", (response) => {\n        if (\n          response.code === NilauthErrorCodeSchema.enum.NOT_SUBSCRIBED ||\n          response.code === NilauthErrorCodeSchema.enum.TRANSACTION_LOOKUP\n        ) {\n          // Return a \"subscribed: false\" success value\n          const status: SubscriptionStatusResponse = {\n            subscribed: false,\n            details: null,\n          };\n          return E.succeed(status);\n        }\n        // Re-throw the error for other cases\n        return E.fail(response);\n      }),\n      assertType<SubscriptionStatusResponse>(),\n      logOutcome(request),\n    );\n  }\n\n  /**\n   * Complete end-to-end payment flow for a Nilauth subscription.\n   *\n   * This method performs three steps:\n   * 1. Fetches the current subscription cost\n   * 2. Makes a payment transaction on Nilchain\n   * 3. Validates the payment with the Nilauth service\n   *\n   * @returns Promise resolving when payment and validation succeed, or throws on failure.\n   */\n  payAndValidate(publicKey: string, blindModule: BlindModule): Promise<void> {\n    return unwrapEffect(\n      pipe(\n        this.subscriptionCostEffect(blindModule),\n        E.flatMap((cost) => this.payEffect(cost, blindModule)),\n        E.flatMap(({ txHash, payloadHex }) =>\n          this.validatePaymentEffect({ publicKey, txHash, payloadHex }),\n        ),\n      ),\n    );\n  }\n\n  /**\n   * Create and submit a payment transaction for a subscription.\n   *\n   * Uses the configured payer to submit a transaction to Nilchain for the specified amount.\n   *\n   * @param amount - The payment amount in unils.\n   * @param blindModule - The module for which the payment is made (e.g., \"nilai\" or \"nildb\").\n   * @returns Effect resolving to the transaction hash and payload, or failing with a payment error.\n   */\n  payEffect(\n    amount: number,\n    blindModule: BlindModule,\n  ): E.Effect<{ txHash: string; payloadHex: Hex }, PaymentTxFailed> {\n    const payload = JSON.stringify({\n      nonce: generateNonce(),\n      service_public_key: this.nilauthPublicKey,\n      blind_module: blindModule,\n    });\n    const payloadHex = toHex(payload);\n    const payloadDigest = sha256(payload);\n    log(\n      `Making payment with payload=${payloadHex}, digest=${bytesToHex(payloadDigest)}`,\n    );\n\n    const request = {\n      hash: sha256(payload),\n      cost: amount,\n    };\n\n    return pipe(\n      E.tryPromise({\n        try: () => this.payer.pay(request.hash, request.cost),\n        catch: (cause) => new PaymentTxFailed({ cause }),\n      }),\n      E.map((txHash) => ({ txHash, payloadHex })),\n    );\n  }\n\n  /**\n   * Notify the Nilauth service about a completed payment transaction.\n   *\n   * After making a payment on Nilchain, this method validates the transaction with\n   * the Nilauth service to activate the subscription. It automatically retries\n   * if the transaction has not yet been committed to the blockchain.\n   *\n   * @param config - Configuration object containing:\n   * - `publicKey`: The public key of the account for which to activate the subscription.\n   * - `txHash`: The transaction hash of the payment made on Nilchain.\n   * - `payloadHex`: The hex-encoded payload used in the payment transaction.\n   * @returns Effect resolving to the validation response or failing with typed errors.\n   */\n  validatePaymentEffect(config: {\n    publicKey: string;\n    txHash: string;\n    payloadHex: Hex;\n  }): E.Effect<\n    ValidatePaymentResponse,\n    ZodError | InvalidContentType | FetchError\n  > {\n    const { publicKey, txHash, payloadHex } = config;\n    const url = NilauthUrl.payments.validate(this.nilauthBaseUrl);\n\n    const request: RequestOptions = {\n      url,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: {\n        tx_hash: txHash,\n        payload: payloadHex,\n        public_key: publicKey,\n      },\n    };\n\n    const retry = {\n      baseDelay: D.millis(200),\n      max: 3,\n    };\n\n    const schedule = S.exponential(retry.baseDelay)\n      .pipe(S.jittered)\n      .pipe((s) => S.intersect(s, S.recurs(retry.max)))\n      .pipe((s) =>\n        S.onDecision(s, (delay, decision) =>\n          E.sync(() => {\n            switch (decision._tag) {\n              case \"Continue\":\n                log(\n                  `Retrying request to ${request.url} after ${delay}ms delay`,\n                );\n                break;\n              case \"Done\":\n                log(`Retries exhausted for ${request.url}`);\n                break;\n              default:\n                break;\n            }\n          }),\n        ),\n      );\n\n    return pipe(\n      fetchWithTimeout(request),\n      E.retry({\n        schedule,\n        while: (error) =>\n          error instanceof NilauthErrorResponse &&\n          error.code === NilauthErrorCodeSchema.enum.TRANSACTION_NOT_COMMITTED,\n      }),\n      extractResponseJson(),\n      parseWithZodSchema(ValidatePaymentResponseSchema),\n      assertType<ValidatePaymentResponse>(),\n      logOutcome(request),\n    );\n  }\n\n  /**\n   * Request a new NUC token from the Nilauth service.\n   *\n   * Creates a fresh token that can be used for authentication and authorization\n   * with Nilauth and compatible services.\n   *\n   * Requesting tokens can only be done if a subscription for the blind module is paid.\n   *\n   * @param keypair - The keypair used to sign the request.\n   * @param blindModule - The module for which the token is requested (e.g., \"nilai\" or \"nildb\").\n   * @returns Promise resolving to the created token response.\n   */\n  requestToken(\n    keypair: Keypair,\n    blindModule: BlindModule,\n  ): Promise<CreateTokenResponse> {\n    return pipe(this.requestTokenEffect(keypair, blindModule), unwrapEffect);\n  }\n\n  /**\n   * Effect-based implementation for requesting a new NUC token.\n   *\n   * Provides the same functionality as `requestToken()` but returns an\n   * Effect that can be composed with other operations.\n   *\n   * @param keypair - The keypair used to sign the request.\n   * @param blindModule - The module for which the token is requested (e.g., \"nilai\" or \"nildb\").\n   * @returns Effect resolving to the created token response or failing with typed errors.\n   */\n  requestTokenEffect(\n    keypair: Keypair,\n    blindModule: BlindModule,\n  ): E.Effect<CreateTokenResponse, ZodError | InvalidContentType | FetchError> {\n    const url = NilauthUrl.nucs.create(this.nilauthBaseUrl);\n    const body = createSignedRequest(\n      {\n        nonce: generateNonce(),\n        target_public_key: this.nilauthPublicKey,\n        expires_at: Math.floor(\n          Temporal.Now.instant().add({ seconds: 60 }).epochMilliseconds / 1000,\n        ),\n        blind_module: blindModule,\n      },\n      keypair,\n    );\n    const request: RequestOptions = {\n      url,\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body,\n    };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(CreateTokenResponseSchema),\n      assertType<CreateTokenResponse>(),\n      logOutcome(request),\n    );\n  }\n\n  /**\n   * Revoke a previously issued NUC token.\n   *\n   * This invalidates the specified token by registering a revocation with the\n   * Nilauth service. Any future verification of this token should fail.\n   *\n   * @param config - Configuration object containing:\n   * - `keypair`: The keypair used to sign the revocation request.\n   * - `authToken`: The NUC token envelope used for authentication.\n   * - `tokenToRevoke`: The NUC token envelope to be revoked.\n   * @returns Promise resolving when revocation is successfully registered.\n   */\n  revokeToken(config: {\n    keypair: Keypair;\n    authToken: NucTokenEnvelope;\n    tokenToRevoke: NucTokenEnvelope;\n  }): Promise<void> {\n    const { keypair, authToken, tokenToRevoke } = config;\n    const revokeTokenInvocation = NucTokenBuilder.extending(authToken)\n      .body(new InvocationBody({ token: tokenToRevoke.serialize() }))\n      .command(REVOKE_COMMAND)\n      .audience(Did.fromHex(this.nilauthPublicKey))\n      .build(keypair.privateKey());\n    return unwrapEffect(this.revokeTokenEffect(revokeTokenInvocation));\n  }\n\n  /**\n   * Effect-based implementation for submitting a token revocation.\n   *\n   * Sends a revocation invocation to the Nilauth service to invalidate\n   * the specified token.\n   *\n   * @param revokeTokenInvocation - The serialized revocation invocation.\n   * @returns Effect resolving when revocation succeeds or failing with typed errors.\n   */\n  revokeTokenEffect(\n    revokeTokenInvocation: string,\n  ): E.Effect<void, ZodError | InvalidContentType | FetchError> {\n    const url = NilauthUrl.nucs.revoke(this.nilauthBaseUrl);\n    const request: RequestOptions = {\n      url,\n      method: \"POST\",\n      headers: { Authorization: `Bearer ${revokeTokenInvocation}` },\n    };\n\n    return pipe(\n      fetchWithTimeout(request),\n      extractResponseJson(),\n      parseWithZodSchema(ValidatePaymentResponseSchema),\n      assertType<ValidatePaymentResponse>(),\n      logOutcome({ url, method: \"POST\" }),\n    );\n  }\n\n  /**\n   * Asks the nilauth server to provide, if any, revoked tokens in the proof chain. If any revocations are returned\n   * then any entity receiving the provided token should reject it.\n   *\n   * @param token - The envelope of the token to check.\n   * @returns Promise resolving to the lookup response.\n   */\n  findRevocationsInProofChain(\n    token: NucTokenEnvelope,\n  ): Promise<LookupRevokedTokenResponse> {\n    return unwrapEffect(\n      NilauthClient.findRevocationsInProofChainEffect(\n        this.nilauthBaseUrl,\n        token,\n      ),\n    );\n  }\n}\n\n/**\n * Pipeable combinator to log the outcome (success or failure) of an Effect.\n *\n * Attaches debug logging to any Effect, recording when a request succeeds or fails.\n * Uses the debug log facility with the \"@nillion/nuc\" namespace.\n *\n * @param request - The request options containing the URL and HTTP method.\n * @returns A function that enhances the Effect with logging of outcomes.\n */\nfunction logOutcome<A, E>(\n  request: RequestOptions,\n): (effect: E.Effect<A, E>) => E.Effect<A, E> {\n  const { method, url } = request;\n\n  return (effect) =>\n    effect.pipe(\n      E.tapBoth({\n        onFailure: (e) =>\n          E.sync(() =>\n            log(`Request failed: method=${method} url=${url} error=${e}`),\n          ),\n        onSuccess: () =>\n          E.sync(() => log(`Request succeeded: method=${method} url=${url}`)),\n      }),\n    );\n}\n","import debug from \"debug\";\n\nexport const log = debug(\"@nillion/nuc\");\n","import { Effect as E, pipe } from \"effect\";\nimport { StatusCodes } from \"http-status-codes\";\nimport {\n  NilauthErrorCodeSchema,\n  NilauthErrorResponse,\n  type NilauthErrorResponseBody,\n  NilauthErrorResponseBodySchema,\n  NilauthUnreachable,\n} from \"#/errors\";\nimport { assertType, extractResponseJson, parseWithZodSchema } from \"#/utils\";\n\nconst DEFAULT_REQUEST_TIMEOUT_MS = 10_000;\n\nexport type FetchError = NilauthUnreachable | NilauthErrorResponse;\n\nexport type RequestOptions = {\n  url: string;\n  method: \"POST\" | \"GET\";\n  headers?: Record<string, string>;\n  body?: Record<string, unknown>;\n};\n\n/**\n * Performs a fetch request with a timeout and effectful error handling.\n *\n * - If the request times out, the Effect fails with `NilauthUnreachable`.\n * - If a network or other fetch-related error occurs, the Effect fails with `NilauthUnreachable`.\n * - If the HTTP response is not OK (non-2xx), attempts to parse the error response body as a known\n *   Nilauth error and fail with a typed `NilauthErrorResponse`. If parsing fails, fails with a generic\n *   `NilauthErrorResponse` containing the cause and HTTP status.\n *\n * @param request - The request parameters, including URL, HTTP method, (optional) headers, and body.\n * @returns An Effect that resolves to a Response on success or fails with a `FetchError`.\n */\nexport function fetchWithTimeout(\n  request: RequestOptions,\n): E.Effect<Response, FetchError> {\n  const { url, method, headers, body } = request;\n\n  return pipe(\n    // Attempt the fetch as a Promise, handling abort and network errors.\n    E.tryPromise({\n      try: () => {\n        const controller = new AbortController();\n        // Set up a timeout to abort the request if it takes too long.\n        const timeoutId = setTimeout(\n          () => controller.abort(),\n          DEFAULT_REQUEST_TIMEOUT_MS,\n        );\n\n        try {\n          return fetch(url, {\n            method,\n            headers,\n            body: body ? JSON.stringify(body) : undefined,\n            signal: controller.signal,\n          });\n        } finally {\n          clearTimeout(timeoutId); // clear the timeout.\n        }\n      },\n      // Map any thrown error to a NilauthUnreachable, distinguishing timeout from other errors.\n      catch: (error) => {\n        const cause =\n          error instanceof DOMException && error.name === \"AbortError\"\n            ? \"timed-out\"\n            : error;\n\n        return new NilauthUnreachable({\n          url,\n          cause,\n        });\n      },\n    }),\n    // Handle the HTTP response.\n    E.flatMap((response): E.Effect<Response, FetchError> => {\n      if (response.ok) {\n        // If the response is OK (2xx), succeed with the Response object.\n        return E.succeed(response);\n      }\n\n      // For non-2xx responses, attempt to parse the error response body as a known Nilauth error.\n      return pipe(\n        E.succeed(response),\n        extractResponseJson(),\n        parseWithZodSchema(NilauthErrorResponseBodySchema),\n        assertType<NilauthErrorResponseBody>(),\n\n        // Convert into nilauth error\n        E.map((body) => {\n          return new NilauthErrorResponse({\n            url,\n            code: body.error_code,\n            message: body.message,\n            status: response.status,\n            cause: body,\n          });\n        }),\n\n        // If parsing failed (eg malformed or not json body)\n        E.mapError((cause) => {\n          // This is a TRANSACTION_LOOKUP response workaround since the pipeline below cannot handle the empty content-type header\n          if (\n            url.includes(\"/api/v1/subscriptions/status\") &&\n            response.status === StatusCodes.NOT_FOUND &&\n            response.headers.get(\"content-type\") === null\n          ) {\n            console.log(\"got transaction not found\");\n            return new NilauthErrorResponse({\n              url,\n              code: NilauthErrorCodeSchema.enum.TRANSACTION_LOOKUP,\n              message: \"transaction not found\",\n              status: response.status,\n              cause: response,\n            });\n          }\n\n          return new NilauthErrorResponse({\n            url,\n            code: NilauthErrorCodeSchema.enum.INTERNAL,\n            message: \"Failed to parse non-200 status code\",\n            status: response.status,\n            cause,\n          });\n        }),\n\n        // If we get to this point the response represents a failure, even if it was successfully\n        // parsed, so we need to switch onto the failure track\n        E.flatMap(E.fail),\n      );\n    }),\n  );\n}\n","import { Temporal } from \"temporal-polyfill\";\nimport z from \"zod\";\nimport { NucTokenEnvelopeSchema } from \"#/envelope\";\nimport { EpochSeconds } from \"#/utils\";\n\nconst PUBLIC_KEY_LENGTH = 66;\n\nexport const PublicKeySchema = z\n  .string()\n  .length(PUBLIC_KEY_LENGTH)\n  .brand(\"PublicKey\");\n\nexport type PublicKey = z.infer<typeof PublicKeySchema>;\n\nexport type SignedRequest = {\n  public_key: string;\n  signature: string;\n  payload: string;\n};\n\nexport const NilauthHealthResponseSchema = z.literal(\"OK\");\nexport type NilauthHealthResponse = z.infer<typeof NilauthHealthResponseSchema>;\n\nexport const BuildSchema = z\n  .object({\n    commit: z.string(),\n    timestamp: z.string(),\n  })\n  .transform(({ commit, timestamp }) => ({\n    commit,\n    timestamp: Temporal.Instant.from(timestamp),\n  }));\n\nexport const NilauthAboutResponseSchema = z\n  .object({\n    started: z.string(),\n    public_key: PublicKeySchema,\n    build: BuildSchema,\n  })\n  .transform(({ started, public_key, build }) => ({\n    started: Temporal.Instant.from(started),\n    publicKey: public_key,\n    build,\n  }));\nexport type NilauthAboutResponse = z.output<typeof NilauthAboutResponseSchema>;\n\nexport const ValidatePaymentResponseSchema = z.null().transform(() => {});\nexport type ValidatePaymentResponse = z.infer<\n  typeof ValidatePaymentResponseSchema\n>;\n\nexport const SubscriptionCostResponseSchema = z\n  .object({\n    cost_unils: z.number(),\n  })\n  .transform(({ cost_unils }) => cost_unils);\nexport type SubscriptionCostResponse = z.output<\n  typeof SubscriptionCostResponseSchema\n>;\n\nexport const SubscriptionDetailsSchema = z\n  .object({\n    expires_at: EpochSeconds,\n    renewable_at: EpochSeconds,\n  })\n  .transform(({ expires_at, renewable_at }) => ({\n    expiresAt: Temporal.Instant.fromEpochMilliseconds(expires_at * 1000),\n    renewableAt: Temporal.Instant.fromEpochMilliseconds(renewable_at * 1000),\n  }));\nexport type SubscriptionDetails = z.infer<typeof SubscriptionDetailsSchema>;\n\nexport const SubscriptionStatusResponseSchema = z.object({\n  subscribed: z.boolean(),\n  details: SubscriptionDetailsSchema.nullable(),\n});\nexport type SubscriptionStatusResponse = z.infer<\n  typeof SubscriptionStatusResponseSchema\n>;\n\nexport const CreateTokenResponseSchema = z.object({\n  token: NucTokenEnvelopeSchema,\n});\nexport type CreateTokenResponse = z.infer<typeof CreateTokenResponseSchema>;\n\nexport const RevokedTokenSchema = z\n  .object({\n    token_hash: z.string(),\n    revoked_at: EpochSeconds,\n  })\n  .transform(({ token_hash, revoked_at }) => ({\n    tokenHash: token_hash,\n    revokedAt: Temporal.Instant.fromEpochMilliseconds(revoked_at * 1000),\n  }));\nexport type RevokedToken = z.output<typeof RevokedTokenSchema>;\n\nexport const LookupRevokedTokenResponseSchema = z.object({\n  revoked: z.array(RevokedTokenSchema),\n});\nexport type LookupRevokedTokenResponse = z.output<\n  typeof LookupRevokedTokenResponseSchema\n>;\n","import type { BlindModule } from \"#/nilauth/client\";\nimport type { Hex } from \"#/utils\";\n\n/**\n * Utility object for constructing Nilauth service endpoint URLs.\n *\n * Each method returns the full URL for a particular Nilauth API endpoint,\n * given a base URL for the Nilauth service.\n */\nexport const NilauthUrl = {\n  about: (base: string) => `${base}/about`,\n  health: (base: string) => `${base}/health`,\n  nucs: {\n    create: (base: string) => `${base}/api/v1/nucs/create`,\n    revoke: (base: string) => `${base}/api/v1/revocations/revoke`,\n    findRevocations: (base: string) => `${base}/api/v1/revocations/lookup`,\n  },\n  payments: {\n    cost: (base: string, blindModule: BlindModule) =>\n      `${base}/api/v1/payments/cost?blind_module=${blindModule}`,\n    validate: (base: string) => `${base}/api/v1/payments/validate`,\n  },\n  subscriptions: {\n    status: (base: string, publicKey: Hex, blindModule: BlindModule) =>\n      `${base}/api/v1/subscriptions/status?public_key=${publicKey}&blind_module=${blindModule}`,\n  },\n} as const;\n","import {\n  DirectSecp256k1Wallet,\n  type OfflineSigner,\n  Registry,\n} from \"@cosmjs/proto-signing\";\nimport { GasPrice, SigningStargateClient } from \"@cosmjs/stargate\";\nimport type { Window as KeplrWindow } from \"@keplr-wallet/types\";\nimport { z } from \"zod\";\nimport { Keypair } from \"#/keypair\";\nimport { Payer, PayerConfigSchema } from \"#/payer/client\";\nimport { MsgPayForCompatWrapper } from \"#/payer/grpc-compat\";\nimport {\n  type GasLimit,\n  GasLimitSchema,\n  NilChainAddressPrefix,\n  NilChainProtobufTypeUrl,\n  NilToken,\n} from \"#/payer/types\";\n\ndeclare global {\n  interface Window extends KeplrWindow {}\n}\n\nconst PayerBuilderConfig = z.object({\n  keypair: z.instanceof(Keypair),\n  chainUrl: z.string().url(\"Invalid chain url\"),\n  gasLimit: GasLimitSchema,\n  broadcastTimeoutMs: z.number(),\n  broadcastPollIntervalMs: z.number(),\n});\n\nconst KeplrPayerBuilderConfig = z.object({\n  chainId: z.string(),\n  rpcEndpoint: z.string().url(\"Invalid RPC endpoint\"),\n  gasLimit: GasLimitSchema,\n  broadcastTimeoutMs: z.number(),\n  broadcastPollIntervalMs: z.number(),\n});\n\n/**\n * Payer builder.\n */\nexport class PayerBuilder {\n  private _keypair?: Keypair;\n  private _chainUrl?: string;\n  private _gasLimit: GasLimit = \"auto\";\n  private _broadcastTimeoutMs = 30000;\n  private _broadcastPollIntervalMs = 1000;\n\n  keypair(keypair: Keypair): this {\n    this._keypair = keypair;\n    return this;\n  }\n\n  chainUrl(url: string): this {\n    this._chainUrl = url;\n    return this;\n  }\n\n  gasLimit(gasLimit: GasLimit): this {\n    this._gasLimit = gasLimit;\n    return this;\n  }\n\n  broadcastTimeoutMs(broadcastTimeoutMs: number) {\n    this._broadcastTimeoutMs = broadcastTimeoutMs;\n    return this;\n  }\n\n  broadcastPollIntervalMs(broadcastPollIntervalMs: number) {\n    this._broadcastPollIntervalMs = broadcastPollIntervalMs;\n    return this;\n  }\n\n  async build(): Promise<Payer> {\n    const {\n      keypair,\n      chainUrl,\n      gasLimit,\n      broadcastTimeoutMs,\n      broadcastPollIntervalMs,\n    } = PayerBuilderConfig.parse({\n      keypair: this._keypair,\n      chainUrl: this._chainUrl,\n      gasLimit: this._gasLimit,\n      broadcastTimeoutMs: this._broadcastTimeoutMs,\n      broadcastPollIntervalMs: this._broadcastPollIntervalMs,\n    });\n\n    const signer = await createSignerFromKeyPair(keypair);\n    const accounts = await signer.getAccounts();\n    if (accounts.length === 0) {\n      throw new Error(\"No accounts on the offline signer\");\n    }\n    const address = accounts[0]?.address ?? \"\";\n\n    const registry = new Registry();\n    registry.register(NilChainProtobufTypeUrl, MsgPayForCompatWrapper);\n\n    const client = await SigningStargateClient.connectWithSigner(\n      z.string().url().parse(chainUrl),\n      signer,\n      {\n        gasPrice: GasPrice.fromString(NilToken.asUnil(0.0)),\n        registry,\n        broadcastTimeoutMs,\n        broadcastPollIntervalMs,\n      },\n    );\n\n    const config = PayerConfigSchema.parse({\n      address,\n      client,\n      gasLimit,\n    });\n\n    return new Payer(config);\n  }\n}\n\nexport class KeplrPayerBuilder {\n  private _chainUrl?: string;\n  private _chainId?: string;\n  private _rpcEndpoint?: string;\n  private _gasLimit: GasLimit = \"auto\";\n  private _broadcastTimeoutMs = 30000;\n  private _broadcastPollIntervalMs = 1000;\n\n  chainUrl(url: string): this {\n    this._chainUrl = url;\n    return this;\n  }\n\n  chainId(chainId: string): this {\n    this._chainId = chainId;\n    return this;\n  }\n\n  rpcEndpoint(rpcEndpoint: string): this {\n    this._rpcEndpoint = rpcEndpoint;\n    return this;\n  }\n\n  gasLimit(gasLimit: GasLimit): this {\n    this._gasLimit = gasLimit;\n    return this;\n  }\n\n  broadcastTimeoutMs(broadcastTimeoutMs: number) {\n    this._broadcastTimeoutMs = broadcastTimeoutMs;\n    return this;\n  }\n\n  broadcastPollIntervalMs(broadcastPollIntervalMs: number) {\n    this._broadcastPollIntervalMs = broadcastPollIntervalMs;\n    return this;\n  }\n\n  async build(): Promise<Payer> {\n    const {\n      chainId,\n      rpcEndpoint,\n      gasLimit,\n      broadcastTimeoutMs,\n      broadcastPollIntervalMs,\n    } = KeplrPayerBuilderConfig.parse({\n      chainId: this._chainId,\n      rpcEndpoint: this._rpcEndpoint,\n      gasLimit: this._gasLimit,\n      broadcastTimeoutMs: this._broadcastTimeoutMs,\n      broadcastPollIntervalMs: this._broadcastPollIntervalMs,\n    });\n\n    // Detect Keplr\n    const win = globalThis as KeplrWindow;\n    const { keplr } = win || {};\n    if (!keplr) {\n      throw new Error(\"You need to install Keplr\");\n    }\n\n    // Create the signing client\n    const offlineSigner = win.getOfflineSigner?.(chainId);\n    if (!offlineSigner) {\n      throw new Error(\"No offline signer found\");\n    }\n    const accounts = await offlineSigner.getAccounts();\n    if (accounts.length === 0) {\n      throw new Error(\"No accounts on the offline signer\");\n    }\n    const address = accounts[0]?.address ?? \"\";\n\n    const registry = new Registry();\n    registry.register(NilChainProtobufTypeUrl, MsgPayForCompatWrapper);\n\n    const client = await SigningStargateClient.connectWithSigner(\n      z.string().url().parse(rpcEndpoint),\n      offlineSigner,\n      {\n        gasPrice: GasPrice.fromString(NilToken.asUnil(0.0)),\n        registry,\n        broadcastTimeoutMs,\n        broadcastPollIntervalMs,\n      },\n    );\n\n    const config = PayerConfigSchema.parse({\n      address,\n      client,\n      gasLimit,\n    });\n\n    return new Payer(config);\n  }\n}\n\nasync function createSignerFromKeyPair(\n  keypair: Keypair,\n): Promise<OfflineSigner> {\n  return await DirectSecp256k1Wallet.fromKey(\n    keypair.privateKey(),\n    NilChainAddressPrefix,\n  );\n}\n","import { create } from \"@bufbuild/protobuf\";\nimport { SigningStargateClient } from \"@cosmjs/stargate\";\nimport { Effect as E, pipe } from \"effect\";\nimport { z } from \"zod\";\nimport { MsgPayForSchema } from \"#/gen-proto/nillion/meta/v1/tx_pb\";\nimport { log } from \"#/logger\";\nimport {\n  GasLimitSchema,\n  NilChainAddress,\n  NilChainProtobufTypeUrl,\n  TxHash,\n} from \"#/payer/types\";\n\nexport const PayerConfigSchema = z.object({\n  address: NilChainAddress,\n  client: z.custom<SigningStargateClient>(\n    (value: unknown) => value instanceof SigningStargateClient,\n  ),\n  gasLimit: GasLimitSchema,\n});\n/**\n * Payer configuration.\n *\n * @property {string} address  Nilchain address.\n * @property {SigningStargateClient} client Cosmos client to perform transactions in nilchain\n * @property {string} gasLimit Gas limit strategy auto a fixed value are allowed.\n */\nexport type PayerConfig = z.infer<typeof PayerConfigSchema>;\n\n/**\n * A payer that allows making payments on nilchain.\n */\nexport class Payer {\n  /**\n   * Creates a Payer instance for the given configuration.\n   *\n   * @param config Payer configuration.\n   */\n  constructor(private readonly config: PayerConfig) {}\n\n  /**\n   * Peform a 'MsgPayFor' payment for the given resource.\n   *\n   * @param resource The resource to use in the transaction.\n   * @param amountUnil The amount of unil to send in the payment.\n   */\n  async pay(resource: Uint8Array, amountUnil: number): Promise<TxHash> {\n    const value = create(MsgPayForSchema, {\n      resource,\n      fromAddress: this.config.address,\n      amount: [{ denom: \"unil\", amount: String(amountUnil) }],\n    });\n    return pipe(\n      E.tryPromise(() =>\n        this.config.client.signAndBroadcast(\n          this.config.address,\n          [{ typeUrl: NilChainProtobufTypeUrl, value }],\n          this.config.gasLimit,\n        ),\n      ),\n      E.flatMap((result) => E.try(() => TxHash.parse(result.transactionHash))),\n      E.catchAll((e) => E.fail(e.cause)),\n      E.tapBoth({\n        onSuccess: (hash) =>\n          E.sync(() => log(`Paid ${amountUnil} unil hash: ${hash}`)),\n        onFailure: (e) => E.sync(() => log(`Pay failed: ${e}`)),\n      }),\n      E.runPromise,\n    );\n  }\n}\n","// @generated by protoc-gen-es v2.5.2 with parameter \"target=ts\"\n// @generated from file v1/tx.proto (package nillion.meta.v1, syntax proto3)\n/* eslint-disable */\n\nimport type { GenFile, GenMessage } from \"@bufbuild/protobuf/codegenv2\";\nimport { fileDesc, messageDesc } from \"@bufbuild/protobuf/codegenv2\";\nimport type { Message } from \"@bufbuild/protobuf\";\n\n/**\n * Describes the file v1/tx.proto.\n */\nexport const file_v1_tx: GenFile = /*@__PURE__*/\n  fileDesc(\"Cgt2MS90eC5wcm90bxIPbmlsbGlvbi5tZXRhLnYxIlwKCU1zZ1BheUZvchIQCghyZXNvdXJjZRgBIAEoDBIUCgxmcm9tX2FkZHJlc3MYAiABKAkSJwoGYW1vdW50GAMgAygLMhcubmlsbGlvbi5tZXRhLnYxLkFtb3VudCInCgZBbW91bnQSDQoFZGVub20YASABKAkSDgoGYW1vdW50GAIgASgJQnwKE2NvbS5uaWxsaW9uLm1ldGEudjFCB1R4UHJvdG9QAaICA05NWKoCD05pbGxpb24uTWV0YS5WMcoCD05pbGxpb25cTWV0YVxWMeICG05pbGxpb25cTWV0YVxWMVxHUEJNZXRhZGF0YeoCEU5pbGxpb246Ok1ldGE6OlYxYgZwcm90bzM\");\n\n/**\n * @generated from message nillion.meta.v1.MsgPayFor\n */\nexport type MsgPayFor = Message<\"nillion.meta.v1.MsgPayFor\"> & {\n  /**\n   * @generated from field: bytes resource = 1;\n   */\n  resource: Uint8Array;\n\n  /**\n   * @generated from field: string from_address = 2;\n   */\n  fromAddress: string;\n\n  /**\n   * @generated from field: repeated nillion.meta.v1.Amount amount = 3;\n   */\n  amount: Amount[];\n};\n\n/**\n * Describes the message nillion.meta.v1.MsgPayFor.\n * Use `create(MsgPayForSchema)` to create a new message.\n */\nexport const MsgPayForSchema: GenMessage<MsgPayFor> = /*@__PURE__*/\n  messageDesc(file_v1_tx, 0);\n\n/**\n * @generated from message nillion.meta.v1.Amount\n */\nexport type Amount = Message<\"nillion.meta.v1.Amount\"> & {\n  /**\n   * @generated from field: string denom = 1;\n   */\n  denom: string;\n\n  /**\n   * @generated from field: string amount = 2;\n   */\n  amount: string;\n};\n\n/**\n * Describes the message nillion.meta.v1.Amount.\n * Use `create(AmountSchema)` to create a new message.\n */\nexport const AmountSchema: GenMessage<Amount> = /*@__PURE__*/\n  messageDesc(file_v1_tx, 1);\n\n","import type { OfflineSigner } from \"@cosmjs/proto-signing\";\nimport { z } from \"zod\";\n\nexport const GasLimitSchema = z.union([z.literal(\"auto\"), z.number()]);\nexport type GasLimit = z.infer<typeof GasLimitSchema>;\n\nexport const TxHash = z.string().length(64).base64().brand<\"TxHash\">();\nexport type TxHash = z.infer<typeof TxHash>;\n\nexport const NilChainAddressPrefix = \"nillion\";\nexport const NilChainAddress = z\n  .string()\n  .length(46)\n  .startsWith(NilChainAddressPrefix)\n  .brand<\"Address\">();\nexport type NilChainAddress = z.infer<typeof NilChainAddress>;\n\nexport const NilToken = {\n  Unil: \"unil\",\n  asUnil: (amount: number | string) => `${String(amount)}${NilToken.Unil}`,\n};\n\nexport const NilChainProtobufTypeUrl = \"/nillion.meta.v1.MsgPayFor\";\n\nexport const OfflineSignerSchema = z.custom<OfflineSigner>((value: unknown) => {\n  return (\n    value !== null &&\n    typeof value === \"object\" &&\n    \"getAccounts\" in value &&\n    \"signDirect\" in value\n  );\n});\n\nexport const PrivateKeyBase16 = z\n  .string()\n  .length(64)\n  .brand<\"PrivateKeyBase16\">();\nexport type PrivateKeyBase16 = z.infer<typeof PrivateKeyBase16>;\n","import { create } from \"@bufbuild/protobuf\";\nimport { type BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport type { TsProtoGeneratedType } from \"@cosmjs/proto-signing/build/registry\";\nimport {\n  type MsgPayFor,\n  MsgPayForSchema,\n} from \"#/gen-proto/nillion/meta/v1/tx_pb\";\n\n/**\n * This wrapper maintains API compatibility with the cosmjs library while using `@bufbuild/protobuf`.\n * It bridges the gap between different protobuf implementations during the migration from\n * protobufjs to `@bufbuild/protobuf` and from the cluster's migration from libp2p to gRPC.\n *\n * Only `encode` and `fromPartial` methods are implemented as they are sufficient for sending transactions.\n *\n * We use `@ts-expect-error` because `TsProtoGeneratedType` expects `protobuf.Writer/Reader`,\n * but we're using `BinaryWriter/Reader`. The methods used are compatible between these types,\n * allowing us to bypass the type check safely in this context.\n */\nexport const MsgPayForCompatWrapper: TsProtoGeneratedType = {\n  encode: (\n    message: MsgPayFor,\n    writer: BinaryWriter = new BinaryWriter(),\n  ): BinaryWriter => {\n    if (message.resource.length > 0) {\n      writer.uint32(10).bytes(message.resource);\n    }\n    if (message.fromAddress !== \"\") {\n      writer.uint32(18).string(message.fromAddress);\n    }\n    for (const amount of message.amount) {\n      const amountWriter = new BinaryWriter();\n      if (amount.denom !== \"\") {\n        amountWriter.uint32(10).string(amount.denom);\n      }\n      if (amount.amount !== \"\") {\n        amountWriter.uint32(18).string(amount.amount);\n      }\n      writer.uint32(26).bytes(amountWriter.finish());\n    }\n    return writer;\n  },\n  decode: (_input: BinaryReader | Uint8Array, _length?: number): MsgPayFor => {\n    throw new Error(\"MsgPayForCompatWrapper: decode not implemented\");\n  },\n  fromPartial: (object: Partial<MsgPayFor>): MsgPayFor => {\n    return create(MsgPayForSchema, {\n      resource: object.resource,\n      fromAddress: object.fromAddress,\n      amount: object.amount,\n    });\n  },\n};\n","import { bytesToHex } from \"@noble/hashes/utils\";\nimport { dequal } from \"dequal\";\nimport { Temporal } from \"temporal-polyfill\";\nimport type { DecodedNucToken, NucTokenEnvelope } from \"#/envelope\";\nimport { And, AnyOf, Equals, Not, NotEquals, Or, type Policy } from \"#/policy\";\nimport {\n  DelegationBody,\n  type Did,\n  InvocationBody,\n  type NucToken,\n  REVOKE_COMMAND,\n} from \"#/token\";\nimport { pairwise } from \"#/utils\";\n\nexport const CHAIN_TOO_LONG = \"token chain is too long\";\nexport const COMMAND_NOT_ATTENUATED = \"command is not an attenuation\";\nexport const DIFFERENT_SUBJECTS = \"different subjects in chain\";\nexport const INVALID_AUDIENCE = \"invalid audience\";\nexport const INVALID_SIGNATURES = \"invalid signatures\";\nexport const ISSUER_AUDIENCE_MISMATCH = \"issuer/audience mismatch\";\nexport const MISSING_PROOF = \"proof is missing\";\nexport const NEED_DELEGATION = \"token must be a delegation\";\nexport const NEED_INVOCATION = \"token must be an invocation\";\nexport const NOT_BEFORE_BACKWARDS = \"`not before` cannot move backwards\";\nexport const NOT_BEFORE_NOT_MET = \"`not before` date not met\";\nexport const POLICY_NOT_MET = \"policy not met\";\nexport const POLICY_TOO_DEEP = \"policy is too deep\";\nexport const POLICY_TOO_WIDE = \"policy is too wide\";\nexport const PROOFS_MUST_BE_DELEGATIONS = \"proofs must be delegations\";\nexport const ROOT_KEY_SIGNATURE_MISSING =\n  \"root NUC is not signed by root keypair\";\nexport const SUBJECT_NOT_IN_CHAIN = \"subject not in chain\";\nexport const TOKEN_EXPIRED = \"token is expired\";\nexport const TOO_MANY_PROOFS = \"up to one `prf` in a token is allowed\";\nexport const UNCHAINED_PROOFS = \"extra proofs not part of chain provided\";\n\nexport class InvocationRequirement {\n  constructor(public audience: Did) {}\n}\n\nexport class DelegationRequirement {\n  constructor(public audience: Did) {}\n}\n\nexport type ValidationParametersConfig = {\n  maxChainLength: number;\n  maxPolicyWidth: number;\n  maxPolicyDepth: number;\n  tokenRequirements?: InvocationRequirement | DelegationRequirement;\n};\n\nexport class ValidationParameters {\n  public readonly config: ValidationParametersConfig;\n  constructor(config?: Partial<ValidationParametersConfig>) {\n    this.config = {\n      maxChainLength: 5,\n      maxPolicyWidth: 10,\n      maxPolicyDepth: 5,\n      ...config,\n    };\n  }\n}\n\nexport class NucTokenValidator {\n  constructor(\n    private readonly rootIssuers: Array<Did>,\n    public timeProvider: () => Temporal.Instant = () => Temporal.Now.instant(),\n  ) {}\n\n  validate(\n    envelope: NucTokenEnvelope,\n    parameters: ValidationParameters,\n    context: Record<string, unknown> = {},\n  ): void {\n    if (envelope.proofs.length + 1 > parameters.config.maxChainLength) {\n      throw new Error(CHAIN_TOO_LONG);\n    }\n\n    const token = envelope.token.token;\n    if (token.proofs.length > 1) {\n      throw new Error(TOO_MANY_PROOFS);\n    }\n    const proofs = token.proofs.flatMap((proofHash) =>\n      NucTokenValidator.sortProofs(proofHash, envelope.proofs),\n    );\n\n    const now = this.timeProvider();\n    this.validateProofs(token, proofs);\n    const tokenChain = [...proofs.reverse(), token];\n    NucTokenValidator.validateTokenChain(tokenChain, parameters, now);\n    NucTokenValidator.validateToken(\n      token,\n      proofs,\n      context,\n      parameters.config.tokenRequirements,\n    );\n    try {\n      envelope.validateSignatures();\n    } catch (_) {\n      throw new Error(INVALID_SIGNATURES);\n    }\n  }\n\n  validateProofs(token: NucToken, proofs: Array<NucToken>): void {\n    if (this.rootIssuers.length > 0) {\n      const root = proofs.length > 0 ? proofs[proofs.length - 1] : token;\n      if (!this.rootIssuers.some((issuer) => issuer.isEqual(root.issuer))) {\n        throw new Error(ROOT_KEY_SIGNATURE_MISSING);\n      }\n    }\n    for (const proof of proofs) {\n      if (proof.body instanceof InvocationBody) {\n        throw new Error(PROOFS_MUST_BE_DELEGATIONS);\n      }\n    }\n  }\n\n  static validateTokenChain(\n    tokens: Array<NucToken>,\n    parameters: ValidationParameters,\n    now: Temporal.Instant,\n  ): void {\n    for (const [previous, current] of pairwise(tokens)) {\n      NucTokenValidator.validateRelationshipProperties(previous, current);\n    }\n    for (const token of tokens) {\n      NucTokenValidator.validateTemporalProperties(token, now);\n      if (token.body instanceof DelegationBody) {\n        NucTokenValidator.validatePoliciesProperties(\n          token.body.policies,\n          parameters,\n        );\n      }\n    }\n    if (tokens.length >= 2) {\n      const token = tokens[1];\n      if (!token.issuer.isEqual(token.subject)) {\n        throw new Error(SUBJECT_NOT_IN_CHAIN);\n      }\n    }\n  }\n\n  static validateRelationshipProperties(\n    previous: NucToken,\n    current: NucToken,\n  ): void {\n    if (!previous.audience.isEqual(current.issuer)) {\n      throw new Error(ISSUER_AUDIENCE_MISMATCH);\n    }\n    if (!previous.subject.isEqual(current.subject)) {\n      throw new Error(DIFFERENT_SUBJECTS);\n    }\n    if (\n      !current.command.isAttenuationOf(previous.command) &&\n      !dequal(current.command, REVOKE_COMMAND)\n    ) {\n      throw new Error(COMMAND_NOT_ATTENUATED);\n    }\n    if (\n      previous.notBefore &&\n      current.notBefore &&\n      previous.notBefore.epochMilliseconds > current.notBefore.epochMilliseconds\n    ) {\n      throw new Error(NOT_BEFORE_BACKWARDS);\n    }\n  }\n\n  static validateTemporalProperties(\n    token: NucToken,\n    currentTime: Temporal.Instant,\n  ): void {\n    if (\n      token.expiresAt &&\n      token.expiresAt.epochMilliseconds <= currentTime.epochMilliseconds\n    ) {\n      throw new Error(TOKEN_EXPIRED);\n    }\n    if (\n      token.notBefore &&\n      token.notBefore.epochMilliseconds > currentTime.epochMilliseconds\n    ) {\n      throw new Error(NOT_BEFORE_NOT_MET);\n    }\n  }\n\n  static validatePoliciesProperties(\n    policies: Array<Policy>,\n    parameters: ValidationParameters,\n  ): void {\n    if (policies.length > parameters.config.maxPolicyWidth) {\n      throw new Error(POLICY_TOO_WIDE);\n    }\n    for (const policy of policies) {\n      const properties = PolicyTreeProperties.fromPolicy(policy);\n      if (properties.maxWidth > parameters.config.maxPolicyWidth) {\n        throw new Error(POLICY_TOO_WIDE);\n      }\n      if (properties.maxDepth > parameters.config.maxPolicyDepth) {\n        throw new Error(POLICY_TOO_DEEP);\n      }\n    }\n  }\n\n  static validateToken(\n    token: NucToken,\n    proofs: Array<NucToken>,\n    context: Record<string, unknown>,\n    tokenRequirements?: InvocationRequirement | DelegationRequirement,\n  ): void {\n    switch (token.body.constructor) {\n      case DelegationBody:\n        NucTokenValidator.validateDelegationToken(token, tokenRequirements);\n        break;\n      case InvocationBody:\n        NucTokenValidator.validateInvocationToken(\n          token,\n          proofs,\n          context,\n          tokenRequirements,\n        );\n        break;\n    }\n  }\n\n  static validateDelegationToken(\n    token: NucToken,\n    tokenRequirements?: InvocationRequirement | DelegationRequirement,\n  ): void {\n    if (!tokenRequirements) {\n      return;\n    }\n    switch (tokenRequirements.constructor) {\n      case InvocationRequirement:\n        throw new Error(NEED_INVOCATION);\n      case DelegationRequirement:\n        if (!token.audience.isEqual(tokenRequirements?.audience)) {\n          throw new Error(INVALID_AUDIENCE);\n        }\n    }\n  }\n\n  static validateInvocationToken(\n    token: NucToken,\n    proofs: Array<NucToken>,\n    context: Record<string, unknown>,\n    tokenRequirements?: InvocationRequirement | DelegationRequirement,\n  ): void {\n    const tokenJson = token.toJson();\n    for (const proof of proofs) {\n      NucTokenValidator.validatePolicyEvaluates(proof, tokenJson, context);\n    }\n    if (!tokenRequirements) {\n      return;\n    }\n    switch (tokenRequirements.constructor) {\n      case DelegationRequirement:\n        throw new Error(NEED_DELEGATION);\n      case InvocationRequirement:\n        if (!token.audience.isEqual(tokenRequirements?.audience)) {\n          throw new Error(INVALID_AUDIENCE);\n        }\n    }\n  }\n\n  static validatePolicyEvaluates(\n    proof: NucToken,\n    tokenJson: Record<string, unknown>,\n    context: Record<string, unknown>,\n  ): void {\n    switch (true) {\n      case proof.body instanceof InvocationBody:\n        throw new Error(PROOFS_MUST_BE_DELEGATIONS);\n      case proof.body instanceof DelegationBody: {\n        for (const policy of proof.body.policies) {\n          if (!policy.evaluate(tokenJson, context)) {\n            throw new Error(POLICY_NOT_MET);\n          }\n        }\n      }\n    }\n  }\n\n  static sortProofs(\n    hash: Uint8Array,\n    proofs: Array<DecodedNucToken>,\n  ): Array<NucToken> {\n    const indexedProofs: Array<[Uint8Array, NucToken]> = proofs.map((proof) => [\n      proof.computeHash(),\n      proof.token,\n    ]);\n    const sortedProofs: NucToken[] = [];\n    let nextHash = hash;\n    while (nextHash) {\n      const nextProofIndex = indexedProofs.findIndex(\n        ([hash, _]) => bytesToHex(hash) === bytesToHex(nextHash),\n      );\n      if (nextProofIndex < 0) {\n        throw new Error(MISSING_PROOF);\n      }\n      const nextProof = indexedProofs.splice(nextProofIndex, 1)[0][1];\n      sortedProofs.push(nextProof);\n      if (nextProof.proofs.length > 1) {\n        throw new Error(TOO_MANY_PROOFS);\n      }\n      nextHash = nextProof.proofs[0];\n    }\n    if (indexedProofs && indexedProofs.length > 0) {\n      throw new Error(UNCHAINED_PROOFS);\n    }\n    return sortedProofs;\n  }\n}\n\nexport class PolicyTreeProperties {\n  constructor(private properties: { maxDepth: number; maxWidth: number }) {}\n\n  get maxDepth(): number {\n    return this.properties.maxDepth;\n  }\n\n  set maxDepth(value: number) {\n    this.properties.maxDepth = value;\n  }\n\n  get maxWidth(): number {\n    return this.properties.maxWidth;\n  }\n\n  set maxWidth(value: number) {\n    this.properties.maxWidth = value;\n  }\n\n  static fromPolicy(rootPolicy: Policy): PolicyTreeProperties {\n    switch (true) {\n      case rootPolicy instanceof And:\n      case rootPolicy instanceof Or: {\n        const properties = new PolicyTreeProperties({\n          maxDepth: 0,\n          maxWidth: rootPolicy.conditions.length,\n        });\n        for (const policy of rootPolicy.conditions) {\n          const innerProperties = PolicyTreeProperties.fromPolicy(policy);\n          properties.maxDepth = Math.max(\n            innerProperties.maxDepth,\n            properties.maxDepth,\n          );\n          properties.maxWidth = Math.max(\n            innerProperties.maxWidth,\n            properties.maxWidth,\n          );\n        }\n        properties.maxDepth += 1;\n        return properties;\n      }\n      case rootPolicy instanceof Not: {\n        const properties = PolicyTreeProperties.fromPolicy(\n          rootPolicy.condition,\n        );\n        properties.maxDepth += 1;\n        return properties;\n      }\n      case rootPolicy instanceof Equals:\n      case rootPolicy instanceof NotEquals: {\n        return new PolicyTreeProperties({ maxDepth: 1, maxWidth: 1 });\n      }\n      case rootPolicy instanceof AnyOf: {\n        return new PolicyTreeProperties({\n          maxDepth: 1,\n          maxWidth: rootPolicy.options.length,\n        });\n      }\n      default:\n        throw new Error(\"policy is not supported\");\n    }\n  }\n}\n"],"mappings":"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","names":["bytesToHex","Temporal","bytesToHex","hexToBytes","bytesToHex","dequal","z","z","z","z","z","z","z","bytesToHex","dequal","bytesToHex","hexToBytes","Temporal","bytesToHex","proof","secp256k1","z","z","secp256k1","sha256","bytesToHex","E","pipe","Temporal","E","pipe","pipe","E","body","Temporal","z","z","Temporal","pipe","token","bytesToHex","E","sha256","Temporal","SigningStargateClient","z","E","pipe","z","z","z","pipe","E","create","create","z","SigningStargateClient","bytesToHex","dequal","Temporal","Temporal","dequal","hash","bytesToHex"]}