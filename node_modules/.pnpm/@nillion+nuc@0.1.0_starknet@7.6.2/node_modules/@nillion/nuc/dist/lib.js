// src/builder.ts
import { bytesToHex as bytesToHex4 } from "@noble/hashes/utils";
import { Temporal as Temporal2 } from "temporal-polyfill";

// src/keypair.ts
import { secp256k1 } from "@noble/curves/secp256k1";
import { bytesToHex as bytesToHex3, hexToBytes as hexToBytes2 } from "@noble/hashes/utils";

// src/token.ts
import { bytesToHex as bytesToHex2, hexToBytes } from "@noble/hashes/utils";
import { dequal as dequal2 } from "dequal";
import { Temporal } from "temporal-polyfill";
import { z as z5 } from "zod";

// src/policy.ts
import { dequal } from "dequal";
import { z as z2 } from "zod";

// src/selector.ts
import { z } from "zod";
var ALPHABET_LABEL = /[a-zA-Z0-9_-]+/;
var SelectorSchema = z.string().transform(
  (selector) => selector.startsWith("$") ? { selector: selector.slice(1), target: "context" } : { selector, target: "token" }
).refine(
  ({ selector }) => selector.startsWith("."),
  "selector must start with '.' or '$'"
).transform(({ selector, target }) => {
  const s = selector.slice(1);
  const labels = s ? s.split(".") : [];
  return { labels, target };
}).refine(({ labels }) => labels.every(Boolean), "empty attribute").refine(
  ({ labels, target }) => target === "context" && labels.length > 0 || target === "token"
).refine(
  ({ labels }) => labels.every((label) => ALPHABET_LABEL.test(label)),
  "invalid attribute character"
).transform(({ labels, target }) => new Selector(labels, target));
var Selector = class _Selector {
  constructor(path, target) {
    this.path = path;
    this.target = target;
  }
  /**
   * Apply a selector on a value and return the matched value, if any.
   * @param value The value that this selector could be applied to.
   * @param context The context that this selector could be applied to.
   */
  apply(value, context) {
    switch (this.target) {
      case "token":
        return _Selector.applyOnValue(this.path, value);
      case "context": {
        if (!this.path) return void 0;
        return _Selector.applyOnValue(this.path, context);
      }
    }
  }
  static applyOnValue(path, value) {
    let result = value;
    for (const label of path) {
      if (result !== null && typeof result === "object") {
        const record = result;
        if (label in record) {
          result = record[label];
        } else {
          return void 0;
        }
      } else {
        return void 0;
      }
    }
    return result;
  }
  /**
   * Convert this selector into a string.
   */
  toString() {
    const prefix = this.target === "token" ? "" : "$";
    return `${prefix}.${this.path.join(".")}`;
  }
};

// src/policy.ts
var EqualsSchema = z2.tuple([z2.literal("=="), SelectorSchema, z2.unknown()]).transform((operator) => new Equals(operator[1], operator[2]));
var Equals = class {
  constructor(selector, value) {
    this.selector = selector;
    this.value = value;
  }
  evaluate(record, context) {
    return dequal(this.selector.apply(record, context), this.value);
  }
  serialize() {
    return ["==", this.selector.toString(), this.value];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var NotEqualsSchema = z2.tuple([z2.literal("!="), SelectorSchema, z2.unknown()]).transform((operator) => new NotEquals(operator[1], operator[2]));
var NotEquals = class {
  constructor(selector, value) {
    this.selector = selector;
    this.value = value;
  }
  evaluate(record, context) {
    return !dequal(this.selector.apply(record, context), this.value);
  }
  serialize() {
    return ["!=", this.selector.toString(), this.value];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var AnyOfSchema = z2.tuple([z2.literal("anyOf"), SelectorSchema, z2.array(z2.unknown())]).transform((operator) => new AnyOf(operator[1], operator[2]));
var AnyOf = class {
  constructor(selector, options) {
    this.selector = selector;
    this.options = options;
  }
  evaluate(record, context) {
    const value = this.selector.apply(record, context);
    return Array.from(this.options).some((option) => dequal(value, option));
  }
  serialize() {
    return ["anyOf", this.selector.toString(), this.options];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var OperatorSchema = z2.union([
  EqualsSchema,
  NotEqualsSchema,
  AnyOfSchema
]);
var AndSchema = z2.lazy(() => z2.tuple([z2.literal("and"), z2.array(PolicySchema)])).transform(
  (connector) => new And(connector[1].map((policy) => policy))
);
var And = class {
  constructor(conditions) {
    this.conditions = conditions;
  }
  evaluate(record, context) {
    const conditions = this.conditions;
    return conditions && conditions.length > 0 && conditions.every((condition) => condition.evaluate(record, context));
  }
  serialize() {
    return [
      "and",
      ...this.conditions.map((condition) => condition.serialize())
    ];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var OrSchema = z2.lazy(() => z2.tuple([z2.literal("or"), z2.array(PolicySchema)])).transform(
  (connector) => new Or(connector[1].map((policy) => policy))
);
var Or = class {
  constructor(conditions) {
    this.conditions = conditions;
  }
  evaluate(record, context) {
    return this.conditions.some(
      (condition) => condition.evaluate(record, context)
    );
  }
  serialize() {
    return ["or", ...this.conditions.map((condition) => condition.serialize())];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var NotSchema = z2.lazy(() => z2.tuple([z2.literal("not"), PolicySchema])).transform((connector) => new Not(connector[1]));
var Not = class {
  constructor(condition) {
    this.condition = condition;
  }
  evaluate(record, context) {
    return !this.condition.evaluate(record, context);
  }
  serialize() {
    return ["not", this.condition.serialize()];
  }
  toString() {
    return JSON.stringify(this.serialize());
  }
};
var ConnectorSchema = z2.lazy(
  () => z2.union([AndSchema, OrSchema, NotSchema])
);
var PolicySchema = z2.lazy(
  () => z2.union([ConnectorSchema, OperatorSchema])
);

// src/utils.ts
import { bytesToHex } from "@noble/hashes/utils";
import { base64url } from "@scure/base";
import { Effect as E, pipe } from "effect";
import { z as z4 } from "zod";

// src/errors.ts
import { Data } from "effect";
import { z as z3 } from "zod";
var NilauthUnreachable = class extends Data.TaggedError("NilauthUnreachable") {
  /**
   * Returns a formatted string for logging.
   */
  toString() {
    const causeStr = this.cause instanceof Error ? this.cause.message : this.cause ? String(this.cause) : "unknown";
    return `${this._tag}: ${this.url}${causeStr ? ` cause=${causeStr}` : ""}`;
  }
};
var InvalidContentType = class extends Data.TaggedError("InvalidContentType") {
  /**
   * Returns a formatted string for logging.
   */
  toString() {
    return `${this._tag}: status=${this.response.status} url=${this.response.url} expected=${this.expected} actual=${this.actual} cause=${this.cause.message}`;
  }
};
var PaymentTxFailed = class extends Data.TaggedError("PaymentTxFailed") {
  /**
   * Returns a formatted string for logging.
   */
  toString() {
    const causeStr = this.cause instanceof Error ? this.cause.message : this.cause ? String(this.cause) : "unknown";
    return `${this._tag}: cause=${causeStr}`;
  }
};
var NilauthErrorCodeSchema = z3.enum([
  "CANNOT_RENEW_YET",
  "HASH_MISMATCH",
  "INSUFFICIENT_PAYMENT",
  "INTERNAL",
  "INVALID_PUBLIC_KEY",
  "MALFORMED_PAYLOAD",
  "MALFORMED_TRANSACTION",
  "NOT_SUBSCRIBED",
  "PAYMENT_ALREADY_PROCESSED",
  "TRANSACTION_LOOKUP",
  "TRANSACTION_NOT_COMMITTED",
  "UNKNOWN_PUBLIC_KEY"
]);
var NilauthErrorResponseBodySchema = z3.object({
  message: z3.string(),
  error_code: NilauthErrorCodeSchema
});
var NilauthErrorResponse = class extends Data.TaggedError(
  "NilauthErrorResponse"
) {
  /**
   * Returns a formatted string for logging.
   */
  toString() {
    const causeStr = this.cause instanceof Error ? this.cause.message : this.cause ? String(this.cause) : "";
    return `${this._tag}: [${this.code}] ${this.message} (url=${this.url}, status=${this.status})${causeStr ? ` cause=${causeStr}` : ""}`;
  }
};

// src/utils.ts
var HexSchema = z4.string().regex(/^[a-fA-F0-9]+$/, "invalid hex");
var EpochSeconds = z4.number().int().max(1e12);
var parseEpochSeconds = (value) => {
  try {
    return EpochSeconds.parse(value);
  } catch (_e) {
    throw new Error(`Invalid epoch: ${value}`);
  }
};
function toHex(data) {
  const bytes = new TextEncoder().encode(data);
  return bytesToHex(bytes);
}
function base64UrlEncode(input) {
  const data = typeof input === "string" ? new TextEncoder().encode(input) : input;
  return base64url.encode(data).replace(/=+$/, "");
}
function base64UrlDecode(input) {
  const inputStr = typeof input === "string" ? input : new TextDecoder().decode(input);
  const bytes = base64UrlDecodeToBytes(inputStr);
  return new TextDecoder().decode(bytes);
}
function addBase64Padding(input) {
  const padding = (4 - input.length % 4) % 4;
  return padding > 0 ? input + "=".repeat(padding) : input;
}
function base64UrlDecodeToBytes(input) {
  const padded = addBase64Padding(input);
  return base64url.decode(padded);
}
function pairwise(input) {
  return input.slice(0, -1).map((item, index) => [item, input[index + 1]]);
}
function randomBytes(size) {
  const buffer = new Uint8Array(size);
  globalThis.crypto.getRandomValues(buffer);
  return buffer;
}
function parseWithZodSchema(schema) {
  return (effect) => effect.pipe(
    E.flatMap(
      (data) => E.try({
        try: () => schema.parse(data),
        catch: (e) => e
      })
    )
  );
}
function extractResponseJson() {
  return (effect) => effect.pipe(
    E.flatMap(
      (response) => E.tryPromise({
        try: () => response.json(),
        catch: (cause) => new InvalidContentType({
          actual: response.headers.get("content-type"),
          expected: "plain/text",
          response,
          cause
        })
      })
    )
  );
}
function extractResponseText() {
  return (effect) => effect.pipe(
    E.flatMap(
      (response) => E.tryPromise({
        try: () => response.text(),
        catch: (cause) => new InvalidContentType({
          actual: response.headers.get("content-type"),
          expected: "application/json",
          response,
          cause
        })
      })
    )
  );
}
function assertType() {
  return (effect) => effect;
}
function generateNonce() {
  const bytes = randomBytes(16);
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function createSignedRequest(payload, keypair) {
  const stringifiedPayload = JSON.stringify(payload);
  return {
    public_key: keypair.publicKey("hex"),
    signature: keypair.sign(stringifiedPayload, "hex"),
    payload: toHex(stringifiedPayload)
  };
}
async function unwrapEffect(effect) {
  const result = await pipe(effect, E.either, E.runPromise);
  if (result._tag === "Right") {
    return result.right;
  }
  throw result.left;
}

// src/token.ts
var DID_EXPRESSION = /^did:nil:([a-zA-Z0-9]{66})$/;
var DidSchema = z5.string().transform((did) => DID_EXPRESSION.exec(did)).refine((match) => match !== null, "invalid DID").transform((match) => Did.fromHex(match[1]));
var Did = class _Did {
  /**
   *
   * Creates a new DID for the given public key.
   * @param publicKey Public key in bytes format.
   */
  constructor(publicKey) {
    this.publicKey = publicKey;
  }
  /**
   * Convert this DID into a string.
   */
  toString() {
    return `did:nil:${this.publicKeyAsHex()}`;
  }
  /**
   * Get the public which this DID represents.
   */
  publicKeyAsHex() {
    return bytesToHex2(this.publicKey);
  }
  /**
   * Check if this and another DID are equals.
   * @param other The other DID which will be used for the equality operation.
   */
  isEqual(other) {
    return bytesToHex2(this.publicKey) === bytesToHex2(other.publicKey);
  }
  /**
   * Creates a new DID for the given public key.
   * @param hex Public key in hex format.
   */
  static fromHex(hex) {
    return new _Did(hexToBytes(hex));
  }
};
var CommandSchema = z5.string().startsWith("/", "command must start with '/'").transform((selector) => {
  const s = selector.slice(1);
  if (!s) return [];
  return s.split("/");
}).refine((labels) => labels.every(Boolean), "empty command").transform((segments) => {
  return new Command(segments);
});
var Command = class {
  constructor(segments) {
    this.segments = segments;
  }
  /**
   * Check if this command is an attenuation of another one.
   * @param other The command for which this command is attenuation.
   */
  isAttenuationOf(other) {
    return this.segments.length >= other.segments.length && dequal2(other.segments, this.segments.slice(0, other.segments.length));
  }
  /**
   * Convert this command into a string.
   */
  toString() {
    return `/${this.segments.join("/")}`;
  }
};
var REVOKE_COMMAND = new Command(["nuc", "revoke"]);
var InvocationBodySchema = z5.record(z5.string(), z5.unknown()).transform((args) => new InvocationBody(args));
var InvocationBody = class {
  constructor(args) {
    this.args = args;
  }
};
var DelegationBodySchema = z5.array(PolicySchema).transform((body) => new DelegationBody(body));
var DelegationBody = class {
  constructor(policies) {
    this.policies = policies;
  }
};
var NucTokenSchema = z5.object({
  iss: DidSchema,
  aud: DidSchema,
  sub: DidSchema,
  nbf: EpochSeconds.optional(),
  exp: EpochSeconds.optional(),
  cmd: CommandSchema,
  args: InvocationBodySchema.optional(),
  pol: DelegationBodySchema.optional(),
  meta: z5.record(z5.string(), z5.unknown()).optional(),
  nonce: HexSchema,
  prf: z5.array(z5.string()).default([])
}).transform((token) => {
  return new NucToken({
    issuer: token.iss,
    audience: token.aud,
    subject: token.sub,
    command: token.cmd,
    body: tokenBody(token.args, token.pol),
    nonce: token.nonce,
    proofs: token.prf.map((prf) => hexToBytes(prf)),
    notBefore: token.nbf ? Temporal.Instant.fromEpochMilliseconds(token.nbf * 1e3) : void 0,
    expiresAt: token.exp ? Temporal.Instant.fromEpochMilliseconds(token.exp * 1e3) : void 0,
    meta: token.meta
  });
});
function tokenBody(args, pol) {
  if (args !== void 0 && pol !== void 0)
    throw Error("one of 'args' and 'pol' must be set");
  if (args !== void 0) return args;
  if (pol !== void 0) return pol;
  throw Error("'args' and 'pol' can't both be set");
}
var NucTokenDataSchema = z5.object({
  issuer: z5.instanceof(Did),
  audience: z5.instanceof(Did),
  subject: z5.instanceof(Did),
  notBefore: z5.instanceof(Temporal.Instant).optional(),
  expiresAt: z5.instanceof(Temporal.Instant).optional(),
  command: z5.instanceof(Command),
  body: z5.union([z5.instanceof(DelegationBody), z5.instanceof(InvocationBody)]),
  meta: z5.record(z5.string(), z5.unknown()).optional(),
  nonce: HexSchema,
  proofs: z5.array(z5.instanceof(Uint8Array))
});
var NucToken = class {
  constructor(_data) {
    this._data = _data;
  }
  get issuer() {
    return this._data.issuer;
  }
  get audience() {
    return this._data.audience;
  }
  get subject() {
    return this._data.subject;
  }
  get command() {
    return this._data.command;
  }
  get body() {
    return this._data.body;
  }
  get nonce() {
    return this._data.nonce;
  }
  get proofs() {
    return this._data.proofs ? this._data.proofs : [];
  }
  get notBefore() {
    return this._data.notBefore;
  }
  get expiresAt() {
    return this._data.expiresAt;
  }
  get meta() {
    return this._data.meta;
  }
  /**
   * Convert this token into JSON.
   */
  toJson() {
    return {
      iss: this.issuer.toString(),
      aud: this.audience.toString(),
      sub: this.subject.toString(),
      nbf: this.notBefore ? Math.floor(this.notBefore.epochMilliseconds / 1e3) : void 0,
      exp: this.expiresAt ? Math.floor(this.expiresAt.epochMilliseconds / 1e3) : void 0,
      cmd: this.command.toString(),
      args: this.body instanceof InvocationBody ? this.body.args : void 0,
      pol: this.body instanceof DelegationBody ? this.body.policies.map((policy) => policy.serialize()) : void 0,
      meta: this.meta,
      nonce: this.nonce,
      prf: this.proofs && this.proofs.length > 0 ? this.proofs.map((proof) => bytesToHex2(proof)) : void 0
    };
  }
  /**
   * Convert this command into a string.
   */
  toString() {
    return JSON.stringify(this.toJson());
  }
};

// src/keypair.ts
var Keypair = class _Keypair {
  #privateKey;
  #publicKey;
  /**
   * Creates a Keypair instance from a valid 32-byte private key
   * @param privateKey - The private key as raw bytes
   */
  constructor(privateKey) {
    this.#privateKey = privateKey;
    this.#publicKey = secp256k1.getPublicKey(privateKey);
  }
  privateKey(format) {
    return format === "hex" ? bytesToHex3(this.#privateKey) : new Uint8Array(this.#privateKey);
  }
  publicKey(format) {
    return format === "hex" ? bytesToHex3(this.#publicKey) : new Uint8Array(this.#publicKey);
  }
  /**
   * Returns true if this keypair matches the provided public key
   */
  matchesPublicKey(pk) {
    const compareKeyHex = typeof pk === "string" ? pk : bytesToHex3(pk);
    return this.publicKey("hex") === compareKeyHex;
  }
  /**
   * Returns a Did
   */
  toDid() {
    return new Did(this.#publicKey);
  }
  /**
   * Returns a stringified Did, e.g., did:nil:<public_key_as_hex>
   */
  toDidString() {
    return this.toDid().toString();
  }
  static from(privateKey) {
    const bytes = typeof privateKey === "string" ? hexToBytes2(privateKey) : privateKey;
    return new _Keypair(bytes);
  }
  /**
   * Generates a new cryptographically secure random key pair
   * @returns A new Keypair instance
   */
  static generate() {
    return new _Keypair(secp256k1.utils.randomPrivateKey());
  }
  sign(msg, signatureFormat) {
    const msgBytes = new TextEncoder().encode(msg);
    const signature = secp256k1.sign(msgBytes, this.privateKey(), {
      prehash: true
    });
    return signatureFormat === "hex" ? signature.toCompactHex() : signature.toCompactRawBytes();
  }
};

// src/builder.ts
var DEFAULT_NONCE_LENGTH = 16;
var NucTokenBuilder = class _NucTokenBuilder {
  constructor(_body) {
    this._body = _body;
  }
  _audience;
  _subject;
  _notBefore;
  _expiresAt;
  _command;
  _meta;
  _nonce;
  _proof;
  /**
   * Create a new token builder for a delegation token.
   * @param policies The policies to use in the delegation.
   */
  static delegation(policies) {
    return new _NucTokenBuilder(new DelegationBody(policies));
  }
  /**
   * Creates a new token builder for an invocation.
   * @param args The arguments to use in the invocation.
   */
  static invocation(args) {
    return new _NucTokenBuilder(new InvocationBody(args));
  }
  /**
   * Create a NUC token builder that pulls basic properties from a given NUC token.
   *
   * This pulls the following properties from the given envelope:
   *
   *  * command
   *  * subject
   *
   * @param envelope The envelope to extend.
   */
  static extending(envelope) {
    const token = envelope.token;
    if (token.token.body instanceof InvocationBody) {
      throw Error("cannot extend an invocation");
    }
    return new _NucTokenBuilder(token.token.body).proof(envelope).command(token.token.command).subject(token.token.subject);
  }
  /**
   * Set the audience for the token to be built.
   *
   * The audience must be the entity this token is going to be sent to.
   *
   * @param audience The audience of the token.
   */
  audience(audience) {
    this._audience = audience;
    return this;
  }
  /**
   * Set the body for the token being built.
   *
   * @param body The body for the token.
   */
  body(body) {
    this._body = body;
    return this;
  }
  /**
   * Set the subject for the token to be built.
   *
   * @param subject The subject of the token.
   */
  subject(subject) {
    this._subject = subject;
    return this;
  }
  /**
   * Set the token's `not before` instant.
   *
   * @param epoch The Unix timestamp (in seconds) at which the token becomes valid.
   * @throws Error if the value is not a valid epoch timestamp.
   */
  notBefore(epoch) {
    const notBeforeInSeconds = parseEpochSeconds(epoch);
    this._notBefore = Temporal2.Instant.fromEpochMilliseconds(
      notBeforeInSeconds * 1e3
    );
    return this;
  }
  /**
   * Set the token's `expires at` instant.
   *
   * @param epoch The Unix timestamp (in seconds) at which the token expires.
   * @throws Error if the value is not a valid epoch timestamp.
   */
  expiresAt(epoch) {
    const expiresAtInSeconds = parseEpochSeconds(epoch);
    this._expiresAt = Temporal2.Instant.fromEpochMilliseconds(
      expiresAtInSeconds * 1e3
    );
    return this;
  }
  /**
   * Set the command for the token to be built.
   *
   * @param command The command for the token to be built.
   */
  command(command) {
    this._command = command;
    return this;
  }
  /**
   * Set the metadata for the token to be built.
   *
   * @param meta The metadata for the built token.
   */
  meta(meta) {
    this._meta = meta;
    return this;
  }
  /**
   * Set the nonce for the token to be built.
   *
   * @param nonce The nonce to be set.
   *
   * The nonce doesn't have to be explicitly set and it will default to a random 16 bytes long bytestring if not set.
   */
  nonce(nonce) {
    this._nonce = nonce;
    return this;
  }
  /**
   * Set the proof for the token to be built.
   *
   * It's recommended to call :meth:`NucTokenBuilder.extending` which also takes care of pulling other important fields.
   *
   * @param proof The token to be used as proof.
   */
  proof(proof) {
    this._proof = proof;
    return this;
  }
  /**
   * Build the token, signing it using the given private key.
   *
   * @param key The key to use to sing the token.
   */
  build(key) {
    const keypair = new Keypair(key);
    const proof = this._proof;
    if (proof) {
      proof.validateSignatures();
    }
    const data = NucTokenDataSchema.parse({
      body: this._body,
      issuer: new Did(keypair.publicKey()),
      audience: this._audience,
      subject: this._subject,
      notBefore: this._notBefore,
      expiresAt: this._expiresAt,
      command: this._command,
      meta: this._meta,
      nonce: this._nonce ? this._nonce : bytesToHex4(randomBytes(DEFAULT_NONCE_LENGTH)),
      proofs: proof ? [proof.token.computeHash()] : []
    });
    let token = base64UrlEncode(new NucToken(data).toString());
    const header = base64UrlEncode('{"alg":"ES256K"}');
    token = `${header}.${token}`;
    const signature = keypair.sign(token);
    token = `${token}.${base64UrlEncode(signature)}`;
    if (this._proof) {
      const allProofs = [this._proof.token, ...this._proof.proofs];
      token = `${token}/${allProofs.map((proof2) => proof2.serialize()).join("/")}`;
    }
    return token;
  }
};

// src/envelope.ts
import { secp256k1 as secp256k12 } from "@noble/curves/secp256k1";
import { sha256 } from "@noble/hashes/sha256";
import { toBytes } from "@noble/hashes/utils";
import { z as z6 } from "zod";
var INVALID_JWT_STRUCTURE = "invalid JWT structure";
var INVALID_JWT_HEADER = "invalid JWT header";
var SIGNATURE_VERIFICATION_FAILED = "signature verification failed";
var NucTokenEnvelopeSchema = z6.string().transform((data) => data.split("/")).refine((tokens) => tokens.every(Boolean), "empty token").transform(
  (tokens) => tokens.map((token) => DecodedNucTokenSchema.parse(token))
).refine((tokens) => tokens && tokens.length > 0).transform((tokens) => new NucTokenEnvelope(tokens[0], tokens.slice(1)));
var NucTokenEnvelope = class {
  constructor(token, proofs) {
    this.token = token;
    this.proofs = proofs;
  }
  /**
   * Validate the signature in this envelope.
   *
   * This will raise an exception is the token or any of its proofs is not signed by its issuer.
   */
  validateSignatures() {
    for (const token of [this.token, ...this.proofs]) {
      token.validateSignature();
    }
  }
  /**
   * Serialize this envelope as a JWT-like string.
   */
  serialize() {
    return `${[this.token, ...this.proofs].map((proof) => proof.serialize()).join("/")}`;
  }
};
var HeaderSchema = z6.object({
  alg: z6.literal("ES256K")
});
var DecodedNucTokenSchema = z6.string().transform((data) => data.split(".")).refine((tokens) => tokens && tokens.length === 3, INVALID_JWT_STRUCTURE).refine(
  ([rawHeader, _]) => HeaderSchema.parse(JSON.parse(base64UrlDecode(rawHeader))),
  INVALID_JWT_HEADER
).transform(([rawHeader, rawPayload, rawSignature]) => {
  const token = NucTokenSchema.parse(JSON.parse(base64UrlDecode(rawPayload)));
  const signature = base64UrlDecodeToBytes(rawSignature);
  return new DecodedNucToken(rawHeader, rawPayload, signature, token);
});
var DecodedNucToken = class {
  constructor(rawHeader, rawPayload, signature, token) {
    this.rawHeader = rawHeader;
    this.rawPayload = rawPayload;
    this.signature = signature;
    this.token = token;
  }
  /**
   * Validate the signature in this token.
   */
  validateSignature() {
    const msg = toBytes(`${this.rawHeader}.${this.rawPayload}`);
    if (!secp256k12.verify(this.signature, msg, this.token.issuer.publicKey, {
      prehash: true
    })) {
      throw new Error(SIGNATURE_VERIFICATION_FAILED);
    }
  }
  /**
   * Compute the hash for this token.
   */
  computeHash() {
    return sha256(this.serialize());
  }
  /**
   * Serialize this token as a JWT.
   */
  serialize() {
    return `${this.rawHeader}.${this.rawPayload}.${base64UrlEncode(this.signature)}`;
  }
};

// src/nilauth/client.ts
import { sha256 as sha2562 } from "@noble/hashes/sha256";
import { bytesToHex as bytesToHex5 } from "@noble/hashes/utils";
import { Duration as D, Effect as E3, pipe as pipe3, Schedule as S } from "effect";
import { Temporal as Temporal4 } from "temporal-polyfill";

// src/logger.ts
import debug from "debug";
var log = debug("@nillion/nuc");

// src/nilauth/retryable-fetch.ts
import { Effect as E2, pipe as pipe2 } from "effect";
import { StatusCodes } from "http-status-codes";
var DEFAULT_REQUEST_TIMEOUT_MS = 1e4;
function fetchWithTimeout(request) {
  const { url, method, headers, body } = request;
  return pipe2(
    // Attempt the fetch as a Promise, handling abort and network errors.
    E2.tryPromise({
      try: () => {
        const controller = new AbortController();
        const timeoutId = setTimeout(
          () => controller.abort(),
          DEFAULT_REQUEST_TIMEOUT_MS
        );
        try {
          return fetch(url, {
            method,
            headers,
            body: body ? JSON.stringify(body) : void 0,
            signal: controller.signal
          });
        } finally {
          clearTimeout(timeoutId);
        }
      },
      // Map any thrown error to a NilauthUnreachable, distinguishing timeout from other errors.
      catch: (error) => {
        const cause = error instanceof DOMException && error.name === "AbortError" ? "timed-out" : error;
        return new NilauthUnreachable({
          url,
          cause
        });
      }
    }),
    // Handle the HTTP response.
    E2.flatMap((response) => {
      if (response.ok) {
        return E2.succeed(response);
      }
      return pipe2(
        E2.succeed(response),
        extractResponseJson(),
        parseWithZodSchema(NilauthErrorResponseBodySchema),
        assertType(),
        // Convert into nilauth error
        E2.map((body2) => {
          return new NilauthErrorResponse({
            url,
            code: body2.error_code,
            message: body2.message,
            status: response.status,
            cause: body2
          });
        }),
        // If parsing failed (eg malformed or not json body)
        E2.mapError((cause) => {
          if (url.includes("/api/v1/subscriptions/status") && response.status === StatusCodes.NOT_FOUND && response.headers.get("content-type") === null) {
            console.log("got transaction not found");
            return new NilauthErrorResponse({
              url,
              code: NilauthErrorCodeSchema.enum.TRANSACTION_LOOKUP,
              message: "transaction not found",
              status: response.status,
              cause: response
            });
          }
          return new NilauthErrorResponse({
            url,
            code: NilauthErrorCodeSchema.enum.INTERNAL,
            message: "Failed to parse non-200 status code",
            status: response.status,
            cause
          });
        }),
        // If we get to this point the response represents a failure, even if it was successfully
        // parsed, so we need to switch onto the failure track
        E2.flatMap(E2.fail)
      );
    })
  );
}

// src/nilauth/types.ts
import { Temporal as Temporal3 } from "temporal-polyfill";
import z7 from "zod";
var PUBLIC_KEY_LENGTH = 66;
var PublicKeySchema = z7.string().length(PUBLIC_KEY_LENGTH).brand("PublicKey");
var NilauthHealthResponseSchema = z7.literal("OK");
var BuildSchema = z7.object({
  commit: z7.string(),
  timestamp: z7.string()
}).transform(({ commit, timestamp }) => ({
  commit,
  timestamp: Temporal3.Instant.from(timestamp)
}));
var NilauthAboutResponseSchema = z7.object({
  started: z7.string(),
  public_key: PublicKeySchema,
  build: BuildSchema
}).transform(({ started, public_key, build }) => ({
  started: Temporal3.Instant.from(started),
  publicKey: public_key,
  build
}));
var ValidatePaymentResponseSchema = z7.null().transform(() => {
});
var SubscriptionCostResponseSchema = z7.object({
  cost_unils: z7.number()
}).transform(({ cost_unils }) => cost_unils);
var SubscriptionDetailsSchema = z7.object({
  expires_at: EpochSeconds,
  renewable_at: EpochSeconds
}).transform(({ expires_at, renewable_at }) => ({
  expiresAt: Temporal3.Instant.fromEpochMilliseconds(expires_at * 1e3),
  renewableAt: Temporal3.Instant.fromEpochMilliseconds(renewable_at * 1e3)
}));
var SubscriptionStatusResponseSchema = z7.object({
  subscribed: z7.boolean(),
  details: SubscriptionDetailsSchema.nullable()
});
var CreateTokenResponseSchema = z7.object({
  token: NucTokenEnvelopeSchema
});
var RevokedTokenSchema = z7.object({
  token_hash: z7.string(),
  revoked_at: EpochSeconds
}).transform(({ token_hash, revoked_at }) => ({
  tokenHash: token_hash,
  revokedAt: Temporal3.Instant.fromEpochMilliseconds(revoked_at * 1e3)
}));
var LookupRevokedTokenResponseSchema = z7.object({
  revoked: z7.array(RevokedTokenSchema)
});

// src/nilauth/urls.ts
var NilauthUrl = {
  about: (base) => `${base}/about`,
  health: (base) => `${base}/health`,
  nucs: {
    create: (base) => `${base}/api/v1/nucs/create`,
    revoke: (base) => `${base}/api/v1/revocations/revoke`,
    findRevocations: (base) => `${base}/api/v1/revocations/lookup`
  },
  payments: {
    cost: (base, blindModule) => `${base}/api/v1/payments/cost?blind_module=${blindModule}`,
    validate: (base) => `${base}/api/v1/payments/validate`
  },
  subscriptions: {
    status: (base, publicKey, blindModule) => `${base}/api/v1/subscriptions/status?public_key=${publicKey}&blind_module=${blindModule}`
  }
};

// src/nilauth/client.ts
var NilauthClient = class _NilauthClient {
  /**
   * Initialize a NilauthClient by automatically fetching the service's public key.
   *
   * @param baseUrl - The base URL of the Nilauth service.
   * @param payer - The payer instance used for handling subscription payments.
   * @returns Promise resolving to a fully configured NilauthClient instance.
   */
  static async from(baseUrl, payer) {
    const about = await _NilauthClient.about(baseUrl);
    return new _NilauthClient({
      payer,
      nilauth: {
        baseUrl,
        publicKey: about.publicKey
      }
    });
  }
  /**
   * Fetch service metadata from a Nilauth server.
   *
   * Retrieves information including the service's public key, start time, and build information.
   *
   * @param serviceUrl - The base URL of the Nilauth service.
   * @returns Promise resolving to the service metadata.
   */
  static about(serviceUrl) {
    const url = NilauthUrl.about(serviceUrl);
    const request = { url, method: "GET" };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(NilauthAboutResponseSchema),
      assertType(),
      logOutcome(request),
      unwrapEffect
    );
  }
  /**
   * Perform a health check against a Nilauth server.
   *
   * Used to verify that the server is operational and responding to requests.
   *
   * @param serviceUrl - The base URL of the Nilauth service.
   * @returns Promise resolving to "OK" if the service is healthy.
   */
  static health(serviceUrl) {
    const url = NilauthUrl.health(serviceUrl);
    const request = { url, method: "GET" };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseText(),
      parseWithZodSchema(NilauthHealthResponseSchema),
      assertType(),
      logOutcome(request),
      unwrapEffect
    );
  }
  /**
   * Queries a Nilauth server for any revoked tokens in the provided proof chain.
   *
   * This is a critical validation step in NUC verification. If any revocations are found,
   * the token should be considered invalid and rejected by any receiving entity.
   *
   * @param baseUrl - The base URL of the Nilauth service.
   * @param token - The token envelope containing the proof chain to validate.
   * @returns Promise resolving to a response containing any revoked tokens found.
   */
  static findRevocationsInProofChain(baseUrl, token) {
    return unwrapEffect(
      _NilauthClient.findRevocationsInProofChainEffect(baseUrl, token)
    );
  }
  /**
   * Effect-based implementation for querying revocations in a proof chain.
   *
   * Provides the same functionality as `findRevocationsInProofChain` but returns
   * an Effect that can be composed with other operations.
   *
   * @param baseUrl - The base URL of the Nilauth service.
   * @param token - The token envelope containing the proof chain to validate.
   * @returns Effect resolving to a response with revoked tokens or failing with typed errors.
   */
  static findRevocationsInProofChainEffect(baseUrl, token) {
    const url = NilauthUrl.nucs.findRevocations(baseUrl);
    const body = {
      hashes: [token.token, ...token.proofs].map(
        (token2) => bytesToHex5(token2.computeHash())
      )
    };
    const request = {
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body
    };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(LookupRevokedTokenResponseSchema),
      assertType(),
      logOutcome(request)
    );
  }
  #options;
  /**
   * Construct a NilauthClient directly from configuration options.
   *
   * For most use cases, prefer using the static `from()` method which automatically
   * fetches the service's public key.
   *
   * @param options - Client configuration including keypair, payer, and nilauth service info.
   */
  constructor(options) {
    this.#options = options;
  }
  /**
   * The nilchain payer instance used for handling subscription payments.
   * Used internally during payment operations.
   */
  get payer() {
    return this.#options.payer;
  }
  /**
   * The Nilauth service's public key.
   * Used for verification and authentication.
   */
  get nilauthPublicKey() {
    return this.#options.nilauth.publicKey;
  }
  /**
   * The Nilauth service's base URL.
   * All API endpoints are constructed relative to this URL.
   */
  get nilauthBaseUrl() {
    return this.#options.nilauth.baseUrl;
  }
  /**
   * Retrieve server metadata from the configured Nilauth service.
   *
   * Returns information including the service's public key, start time,
   * and build details.
   *
   * @returns Promise resolving to the service metadata.
   */
  // biome-ignore lint/suspicious/useAdjacentOverloadSignatures: false positive
  about() {
    return _NilauthClient.about(this.nilauthBaseUrl);
  }
  /**
   * Verify that the configured Nilauth service is operational.
   *
   * Performs a simple health check to confirm the server is responding.
   *
   * @returns Promise resolving to "OK" if the service is healthy.
   */
  health() {
    return _NilauthClient.health(this.nilauthBaseUrl);
  }
  /**
   * Fetch the current subscription cost from the Nilauth service.
   *
   * Returns the cost in unils (Nilchain's token units).
   *
   * @param blindModule - The module for which the subscription cost is requested (e.g., "nilai" or "nildb").
   * @returns Promise resolving to the numeric subscription cost.
   */
  subscriptionCost(blindModule) {
    return unwrapEffect(this.subscriptionCostEffect(blindModule));
  }
  /**
   * Effect-based implementation for fetching the current subscription cost.
   *
   * Provides the same functionality as `subscriptionCost()` but returns an
   * Effect that can be composed with other operations.
   *
   * @param blindModule - The module for which the subscription cost is requested (e.g., "nilai" or "nildb").
   * @returns Effect resolving to the subscription cost or failing with typed errors.
   */
  subscriptionCostEffect(blindModule) {
    const url = NilauthUrl.payments.cost(this.nilauthBaseUrl, blindModule);
    const request = { url, method: "GET" };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(SubscriptionCostResponseSchema),
      assertType(),
      logOutcome(request)
    );
  }
  /**
   * Check the current subscription status with the Nilauth service.
   *
   * Returns information about whether the client is subscribed and if so,
   * the subscription's expiration and renewal details.
   *
   * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.
   * @param blindModule - The module for which the subscription status is checked (e.g., "nilai" or "nildb").
   * @returns Promise resolving to the subscription status.
   */
  subscriptionStatus(publicKey, blindModule) {
    return unwrapEffect(this.subscriptionStatusEffect(publicKey, blindModule));
  }
  /**
   * Effect-based implementation for checking subscription status.
   *
   * Returns `{ subscribed: false, details: null }` if not subscribed, or
   * `{ subscribed: true, details: {...} }` with expiration details if subscribed.
   *
   * @param publicKey - The public key whose subscription status will be checked. This key does not need to belong to the payer.
   * @param blindModule - The module for which the subscription status is checked (e.g., "nilai" or "nildb").
   * @returns Effect resolving to the subscription status or failing with typed errors.
   */
  subscriptionStatusEffect(publicKey, blindModule) {
    const url = NilauthUrl.subscriptions.status(
      this.nilauthBaseUrl,
      publicKey,
      blindModule
    );
    const request = {
      url,
      method: "GET",
      headers: { "Content-Type": "application/json" }
    };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(SubscriptionStatusResponseSchema),
      E3.catchTag("NilauthErrorResponse", (response) => {
        if (response.code === NilauthErrorCodeSchema.enum.NOT_SUBSCRIBED || response.code === NilauthErrorCodeSchema.enum.TRANSACTION_LOOKUP) {
          const status = {
            subscribed: false,
            details: null
          };
          return E3.succeed(status);
        }
        return E3.fail(response);
      }),
      assertType(),
      logOutcome(request)
    );
  }
  /**
   * Complete end-to-end payment flow for a Nilauth subscription.
   *
   * This method performs three steps:
   * 1. Fetches the current subscription cost
   * 2. Makes a payment transaction on Nilchain
   * 3. Validates the payment with the Nilauth service
   *
   * @returns Promise resolving when payment and validation succeed, or throws on failure.
   */
  payAndValidate(publicKey, blindModule) {
    return unwrapEffect(
      pipe3(
        this.subscriptionCostEffect(blindModule),
        E3.flatMap((cost) => this.payEffect(cost, blindModule)),
        E3.flatMap(
          ({ txHash, payloadHex }) => this.validatePaymentEffect({ publicKey, txHash, payloadHex })
        )
      )
    );
  }
  /**
   * Create and submit a payment transaction for a subscription.
   *
   * Uses the configured payer to submit a transaction to Nilchain for the specified amount.
   *
   * @param amount - The payment amount in unils.
   * @param blindModule - The module for which the payment is made (e.g., "nilai" or "nildb").
   * @returns Effect resolving to the transaction hash and payload, or failing with a payment error.
   */
  payEffect(amount, blindModule) {
    const payload = JSON.stringify({
      nonce: generateNonce(),
      service_public_key: this.nilauthPublicKey,
      blind_module: blindModule
    });
    const payloadHex = toHex(payload);
    const payloadDigest = sha2562(payload);
    log(
      `Making payment with payload=${payloadHex}, digest=${bytesToHex5(payloadDigest)}`
    );
    const request = {
      hash: sha2562(payload),
      cost: amount
    };
    return pipe3(
      E3.tryPromise({
        try: () => this.payer.pay(request.hash, request.cost),
        catch: (cause) => new PaymentTxFailed({ cause })
      }),
      E3.map((txHash) => ({ txHash, payloadHex }))
    );
  }
  /**
   * Notify the Nilauth service about a completed payment transaction.
   *
   * After making a payment on Nilchain, this method validates the transaction with
   * the Nilauth service to activate the subscription. It automatically retries
   * if the transaction has not yet been committed to the blockchain.
   *
   * @param config - Configuration object containing:
   * - `publicKey`: The public key of the account for which to activate the subscription.
   * - `txHash`: The transaction hash of the payment made on Nilchain.
   * - `payloadHex`: The hex-encoded payload used in the payment transaction.
   * @returns Effect resolving to the validation response or failing with typed errors.
   */
  validatePaymentEffect(config) {
    const { publicKey, txHash, payloadHex } = config;
    const url = NilauthUrl.payments.validate(this.nilauthBaseUrl);
    const request = {
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: {
        tx_hash: txHash,
        payload: payloadHex,
        public_key: publicKey
      }
    };
    const retry = {
      baseDelay: D.millis(200),
      max: 3
    };
    const schedule = S.exponential(retry.baseDelay).pipe(S.jittered).pipe((s) => S.intersect(s, S.recurs(retry.max))).pipe(
      (s) => S.onDecision(
        s,
        (delay, decision) => E3.sync(() => {
          switch (decision._tag) {
            case "Continue":
              log(
                `Retrying request to ${request.url} after ${delay}ms delay`
              );
              break;
            case "Done":
              log(`Retries exhausted for ${request.url}`);
              break;
            default:
              break;
          }
        })
      )
    );
    return pipe3(
      fetchWithTimeout(request),
      E3.retry({
        schedule,
        while: (error) => error instanceof NilauthErrorResponse && error.code === NilauthErrorCodeSchema.enum.TRANSACTION_NOT_COMMITTED
      }),
      extractResponseJson(),
      parseWithZodSchema(ValidatePaymentResponseSchema),
      assertType(),
      logOutcome(request)
    );
  }
  /**
   * Request a new NUC token from the Nilauth service.
   *
   * Creates a fresh token that can be used for authentication and authorization
   * with Nilauth and compatible services.
   *
   * Requesting tokens can only be done if a subscription for the blind module is paid.
   *
   * @param keypair - The keypair used to sign the request.
   * @param blindModule - The module for which the token is requested (e.g., "nilai" or "nildb").
   * @returns Promise resolving to the created token response.
   */
  requestToken(keypair, blindModule) {
    return pipe3(this.requestTokenEffect(keypair, blindModule), unwrapEffect);
  }
  /**
   * Effect-based implementation for requesting a new NUC token.
   *
   * Provides the same functionality as `requestToken()` but returns an
   * Effect that can be composed with other operations.
   *
   * @param keypair - The keypair used to sign the request.
   * @param blindModule - The module for which the token is requested (e.g., "nilai" or "nildb").
   * @returns Effect resolving to the created token response or failing with typed errors.
   */
  requestTokenEffect(keypair, blindModule) {
    const url = NilauthUrl.nucs.create(this.nilauthBaseUrl);
    const body = createSignedRequest(
      {
        nonce: generateNonce(),
        target_public_key: this.nilauthPublicKey,
        expires_at: Math.floor(
          Temporal4.Now.instant().add({ seconds: 60 }).epochMilliseconds / 1e3
        ),
        blind_module: blindModule
      },
      keypair
    );
    const request = {
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body
    };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(CreateTokenResponseSchema),
      assertType(),
      logOutcome(request)
    );
  }
  /**
   * Revoke a previously issued NUC token.
   *
   * This invalidates the specified token by registering a revocation with the
   * Nilauth service. Any future verification of this token should fail.
   *
   * @param config - Configuration object containing:
   * - `keypair`: The keypair used to sign the revocation request.
   * - `authToken`: The NUC token envelope used for authentication.
   * - `tokenToRevoke`: The NUC token envelope to be revoked.
   * @returns Promise resolving when revocation is successfully registered.
   */
  revokeToken(config) {
    const { keypair, authToken, tokenToRevoke } = config;
    const revokeTokenInvocation = NucTokenBuilder.extending(authToken).body(new InvocationBody({ token: tokenToRevoke.serialize() })).command(REVOKE_COMMAND).audience(Did.fromHex(this.nilauthPublicKey)).build(keypair.privateKey());
    return unwrapEffect(this.revokeTokenEffect(revokeTokenInvocation));
  }
  /**
   * Effect-based implementation for submitting a token revocation.
   *
   * Sends a revocation invocation to the Nilauth service to invalidate
   * the specified token.
   *
   * @param revokeTokenInvocation - The serialized revocation invocation.
   * @returns Effect resolving when revocation succeeds or failing with typed errors.
   */
  revokeTokenEffect(revokeTokenInvocation) {
    const url = NilauthUrl.nucs.revoke(this.nilauthBaseUrl);
    const request = {
      url,
      method: "POST",
      headers: { Authorization: `Bearer ${revokeTokenInvocation}` }
    };
    return pipe3(
      fetchWithTimeout(request),
      extractResponseJson(),
      parseWithZodSchema(ValidatePaymentResponseSchema),
      assertType(),
      logOutcome({ url, method: "POST" })
    );
  }
  /**
   * Asks the nilauth server to provide, if any, revoked tokens in the proof chain. If any revocations are returned
   * then any entity receiving the provided token should reject it.
   *
   * @param token - The envelope of the token to check.
   * @returns Promise resolving to the lookup response.
   */
  findRevocationsInProofChain(token) {
    return unwrapEffect(
      _NilauthClient.findRevocationsInProofChainEffect(
        this.nilauthBaseUrl,
        token
      )
    );
  }
};
function logOutcome(request) {
  const { method, url } = request;
  return (effect) => effect.pipe(
    E3.tapBoth({
      onFailure: (e) => E3.sync(
        () => log(`Request failed: method=${method} url=${url} error=${e}`)
      ),
      onSuccess: () => E3.sync(() => log(`Request succeeded: method=${method} url=${url}`))
    })
  );
}

// src/payer/builder.ts
import {
  DirectSecp256k1Wallet,
  Registry
} from "@cosmjs/proto-signing";
import { GasPrice, SigningStargateClient as SigningStargateClient2 } from "@cosmjs/stargate";
import { z as z10 } from "zod";

// src/payer/client.ts
import { create } from "@bufbuild/protobuf";
import { SigningStargateClient } from "@cosmjs/stargate";
import { Effect as E4, pipe as pipe4 } from "effect";
import { z as z9 } from "zod";

// src/gen-proto/nillion/meta/v1/tx_pb.ts
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
var file_v1_tx = /* @__PURE__ */ fileDesc("Cgt2MS90eC5wcm90bxIPbmlsbGlvbi5tZXRhLnYxIlwKCU1zZ1BheUZvchIQCghyZXNvdXJjZRgBIAEoDBIUCgxmcm9tX2FkZHJlc3MYAiABKAkSJwoGYW1vdW50GAMgAygLMhcubmlsbGlvbi5tZXRhLnYxLkFtb3VudCInCgZBbW91bnQSDQoFZGVub20YASABKAkSDgoGYW1vdW50GAIgASgJQnwKE2NvbS5uaWxsaW9uLm1ldGEudjFCB1R4UHJvdG9QAaICA05NWKoCD05pbGxpb24uTWV0YS5WMcoCD05pbGxpb25cTWV0YVxWMeICG05pbGxpb25cTWV0YVxWMVxHUEJNZXRhZGF0YeoCEU5pbGxpb246Ok1ldGE6OlYxYgZwcm90bzM");
var MsgPayForSchema = /* @__PURE__ */ messageDesc(file_v1_tx, 0);

// src/payer/types.ts
import { z as z8 } from "zod";
var GasLimitSchema = z8.union([z8.literal("auto"), z8.number()]);
var TxHash = z8.string().length(64).base64().brand();
var NilChainAddressPrefix = "nillion";
var NilChainAddress = z8.string().length(46).startsWith(NilChainAddressPrefix).brand();
var NilToken = {
  Unil: "unil",
  asUnil: (amount) => `${String(amount)}${NilToken.Unil}`
};
var NilChainProtobufTypeUrl = "/nillion.meta.v1.MsgPayFor";
var OfflineSignerSchema = z8.custom((value) => {
  return value !== null && typeof value === "object" && "getAccounts" in value && "signDirect" in value;
});
var PrivateKeyBase16 = z8.string().length(64).brand();

// src/payer/client.ts
var PayerConfigSchema = z9.object({
  address: NilChainAddress,
  client: z9.custom(
    (value) => value instanceof SigningStargateClient
  ),
  gasLimit: GasLimitSchema
});
var Payer = class {
  /**
   * Creates a Payer instance for the given configuration.
   *
   * @param config Payer configuration.
   */
  constructor(config) {
    this.config = config;
  }
  /**
   * Peform a 'MsgPayFor' payment for the given resource.
   *
   * @param resource The resource to use in the transaction.
   * @param amountUnil The amount of unil to send in the payment.
   */
  async pay(resource, amountUnil) {
    const value = create(MsgPayForSchema, {
      resource,
      fromAddress: this.config.address,
      amount: [{ denom: "unil", amount: String(amountUnil) }]
    });
    return pipe4(
      E4.tryPromise(
        () => this.config.client.signAndBroadcast(
          this.config.address,
          [{ typeUrl: NilChainProtobufTypeUrl, value }],
          this.config.gasLimit
        )
      ),
      E4.flatMap((result) => E4.try(() => TxHash.parse(result.transactionHash))),
      E4.catchAll((e) => E4.fail(e.cause)),
      E4.tapBoth({
        onSuccess: (hash) => E4.sync(() => log(`Paid ${amountUnil} unil hash: ${hash}`)),
        onFailure: (e) => E4.sync(() => log(`Pay failed: ${e}`))
      }),
      E4.runPromise
    );
  }
};

// src/payer/grpc-compat.ts
import { create as create2 } from "@bufbuild/protobuf";
import { BinaryWriter } from "@bufbuild/protobuf/wire";
var MsgPayForCompatWrapper = {
  encode: (message, writer = new BinaryWriter()) => {
    if (message.resource.length > 0) {
      writer.uint32(10).bytes(message.resource);
    }
    if (message.fromAddress !== "") {
      writer.uint32(18).string(message.fromAddress);
    }
    for (const amount of message.amount) {
      const amountWriter = new BinaryWriter();
      if (amount.denom !== "") {
        amountWriter.uint32(10).string(amount.denom);
      }
      if (amount.amount !== "") {
        amountWriter.uint32(18).string(amount.amount);
      }
      writer.uint32(26).bytes(amountWriter.finish());
    }
    return writer;
  },
  decode: (_input, _length) => {
    throw new Error("MsgPayForCompatWrapper: decode not implemented");
  },
  fromPartial: (object) => {
    return create2(MsgPayForSchema, {
      resource: object.resource,
      fromAddress: object.fromAddress,
      amount: object.amount
    });
  }
};

// src/payer/builder.ts
var PayerBuilderConfig = z10.object({
  keypair: z10.instanceof(Keypair),
  chainUrl: z10.string().url("Invalid chain url"),
  gasLimit: GasLimitSchema,
  broadcastTimeoutMs: z10.number(),
  broadcastPollIntervalMs: z10.number()
});
var KeplrPayerBuilderConfig = z10.object({
  chainId: z10.string(),
  rpcEndpoint: z10.string().url("Invalid RPC endpoint"),
  gasLimit: GasLimitSchema,
  broadcastTimeoutMs: z10.number(),
  broadcastPollIntervalMs: z10.number()
});
var PayerBuilder = class {
  _keypair;
  _chainUrl;
  _gasLimit = "auto";
  _broadcastTimeoutMs = 3e4;
  _broadcastPollIntervalMs = 1e3;
  keypair(keypair) {
    this._keypair = keypair;
    return this;
  }
  chainUrl(url) {
    this._chainUrl = url;
    return this;
  }
  gasLimit(gasLimit) {
    this._gasLimit = gasLimit;
    return this;
  }
  broadcastTimeoutMs(broadcastTimeoutMs) {
    this._broadcastTimeoutMs = broadcastTimeoutMs;
    return this;
  }
  broadcastPollIntervalMs(broadcastPollIntervalMs) {
    this._broadcastPollIntervalMs = broadcastPollIntervalMs;
    return this;
  }
  async build() {
    const {
      keypair,
      chainUrl,
      gasLimit,
      broadcastTimeoutMs,
      broadcastPollIntervalMs
    } = PayerBuilderConfig.parse({
      keypair: this._keypair,
      chainUrl: this._chainUrl,
      gasLimit: this._gasLimit,
      broadcastTimeoutMs: this._broadcastTimeoutMs,
      broadcastPollIntervalMs: this._broadcastPollIntervalMs
    });
    const signer = await createSignerFromKeyPair(keypair);
    const accounts = await signer.getAccounts();
    if (accounts.length === 0) {
      throw new Error("No accounts on the offline signer");
    }
    const address = accounts[0]?.address ?? "";
    const registry = new Registry();
    registry.register(NilChainProtobufTypeUrl, MsgPayForCompatWrapper);
    const client = await SigningStargateClient2.connectWithSigner(
      z10.string().url().parse(chainUrl),
      signer,
      {
        gasPrice: GasPrice.fromString(NilToken.asUnil(0)),
        registry,
        broadcastTimeoutMs,
        broadcastPollIntervalMs
      }
    );
    const config = PayerConfigSchema.parse({
      address,
      client,
      gasLimit
    });
    return new Payer(config);
  }
};
var KeplrPayerBuilder = class {
  _chainUrl;
  _chainId;
  _rpcEndpoint;
  _gasLimit = "auto";
  _broadcastTimeoutMs = 3e4;
  _broadcastPollIntervalMs = 1e3;
  chainUrl(url) {
    this._chainUrl = url;
    return this;
  }
  chainId(chainId) {
    this._chainId = chainId;
    return this;
  }
  rpcEndpoint(rpcEndpoint) {
    this._rpcEndpoint = rpcEndpoint;
    return this;
  }
  gasLimit(gasLimit) {
    this._gasLimit = gasLimit;
    return this;
  }
  broadcastTimeoutMs(broadcastTimeoutMs) {
    this._broadcastTimeoutMs = broadcastTimeoutMs;
    return this;
  }
  broadcastPollIntervalMs(broadcastPollIntervalMs) {
    this._broadcastPollIntervalMs = broadcastPollIntervalMs;
    return this;
  }
  async build() {
    const {
      chainId,
      rpcEndpoint,
      gasLimit,
      broadcastTimeoutMs,
      broadcastPollIntervalMs
    } = KeplrPayerBuilderConfig.parse({
      chainId: this._chainId,
      rpcEndpoint: this._rpcEndpoint,
      gasLimit: this._gasLimit,
      broadcastTimeoutMs: this._broadcastTimeoutMs,
      broadcastPollIntervalMs: this._broadcastPollIntervalMs
    });
    const win = globalThis;
    const { keplr } = win || {};
    if (!keplr) {
      throw new Error("You need to install Keplr");
    }
    const offlineSigner = win.getOfflineSigner?.(chainId);
    if (!offlineSigner) {
      throw new Error("No offline signer found");
    }
    const accounts = await offlineSigner.getAccounts();
    if (accounts.length === 0) {
      throw new Error("No accounts on the offline signer");
    }
    const address = accounts[0]?.address ?? "";
    const registry = new Registry();
    registry.register(NilChainProtobufTypeUrl, MsgPayForCompatWrapper);
    const client = await SigningStargateClient2.connectWithSigner(
      z10.string().url().parse(rpcEndpoint),
      offlineSigner,
      {
        gasPrice: GasPrice.fromString(NilToken.asUnil(0)),
        registry,
        broadcastTimeoutMs,
        broadcastPollIntervalMs
      }
    );
    const config = PayerConfigSchema.parse({
      address,
      client,
      gasLimit
    });
    return new Payer(config);
  }
};
async function createSignerFromKeyPair(keypair) {
  return await DirectSecp256k1Wallet.fromKey(
    keypair.privateKey(),
    NilChainAddressPrefix
  );
}

// src/validate.ts
import { bytesToHex as bytesToHex6 } from "@noble/hashes/utils";
import { dequal as dequal3 } from "dequal";
import { Temporal as Temporal5 } from "temporal-polyfill";
var CHAIN_TOO_LONG = "token chain is too long";
var COMMAND_NOT_ATTENUATED = "command is not an attenuation";
var DIFFERENT_SUBJECTS = "different subjects in chain";
var INVALID_AUDIENCE = "invalid audience";
var INVALID_SIGNATURES = "invalid signatures";
var ISSUER_AUDIENCE_MISMATCH = "issuer/audience mismatch";
var MISSING_PROOF = "proof is missing";
var NEED_DELEGATION = "token must be a delegation";
var NEED_INVOCATION = "token must be an invocation";
var NOT_BEFORE_BACKWARDS = "`not before` cannot move backwards";
var NOT_BEFORE_NOT_MET = "`not before` date not met";
var POLICY_NOT_MET = "policy not met";
var POLICY_TOO_DEEP = "policy is too deep";
var POLICY_TOO_WIDE = "policy is too wide";
var PROOFS_MUST_BE_DELEGATIONS = "proofs must be delegations";
var ROOT_KEY_SIGNATURE_MISSING = "root NUC is not signed by root keypair";
var SUBJECT_NOT_IN_CHAIN = "subject not in chain";
var TOKEN_EXPIRED = "token is expired";
var TOO_MANY_PROOFS = "up to one `prf` in a token is allowed";
var UNCHAINED_PROOFS = "extra proofs not part of chain provided";
var InvocationRequirement = class {
  constructor(audience) {
    this.audience = audience;
  }
};
var DelegationRequirement = class {
  constructor(audience) {
    this.audience = audience;
  }
};
var ValidationParameters = class {
  config;
  constructor(config) {
    this.config = {
      maxChainLength: 5,
      maxPolicyWidth: 10,
      maxPolicyDepth: 5,
      ...config
    };
  }
};
var NucTokenValidator = class _NucTokenValidator {
  constructor(rootIssuers, timeProvider = () => Temporal5.Now.instant()) {
    this.rootIssuers = rootIssuers;
    this.timeProvider = timeProvider;
  }
  validate(envelope, parameters, context = {}) {
    if (envelope.proofs.length + 1 > parameters.config.maxChainLength) {
      throw new Error(CHAIN_TOO_LONG);
    }
    const token = envelope.token.token;
    if (token.proofs.length > 1) {
      throw new Error(TOO_MANY_PROOFS);
    }
    const proofs = token.proofs.flatMap(
      (proofHash) => _NucTokenValidator.sortProofs(proofHash, envelope.proofs)
    );
    const now = this.timeProvider();
    this.validateProofs(token, proofs);
    const tokenChain = [...proofs.reverse(), token];
    _NucTokenValidator.validateTokenChain(tokenChain, parameters, now);
    _NucTokenValidator.validateToken(
      token,
      proofs,
      context,
      parameters.config.tokenRequirements
    );
    try {
      envelope.validateSignatures();
    } catch (_) {
      throw new Error(INVALID_SIGNATURES);
    }
  }
  validateProofs(token, proofs) {
    if (this.rootIssuers.length > 0) {
      const root = proofs.length > 0 ? proofs[proofs.length - 1] : token;
      if (!this.rootIssuers.some((issuer) => issuer.isEqual(root.issuer))) {
        throw new Error(ROOT_KEY_SIGNATURE_MISSING);
      }
    }
    for (const proof of proofs) {
      if (proof.body instanceof InvocationBody) {
        throw new Error(PROOFS_MUST_BE_DELEGATIONS);
      }
    }
  }
  static validateTokenChain(tokens, parameters, now) {
    for (const [previous, current] of pairwise(tokens)) {
      _NucTokenValidator.validateRelationshipProperties(previous, current);
    }
    for (const token of tokens) {
      _NucTokenValidator.validateTemporalProperties(token, now);
      if (token.body instanceof DelegationBody) {
        _NucTokenValidator.validatePoliciesProperties(
          token.body.policies,
          parameters
        );
      }
    }
    if (tokens.length >= 2) {
      const token = tokens[1];
      if (!token.issuer.isEqual(token.subject)) {
        throw new Error(SUBJECT_NOT_IN_CHAIN);
      }
    }
  }
  static validateRelationshipProperties(previous, current) {
    if (!previous.audience.isEqual(current.issuer)) {
      throw new Error(ISSUER_AUDIENCE_MISMATCH);
    }
    if (!previous.subject.isEqual(current.subject)) {
      throw new Error(DIFFERENT_SUBJECTS);
    }
    if (!current.command.isAttenuationOf(previous.command) && !dequal3(current.command, REVOKE_COMMAND)) {
      throw new Error(COMMAND_NOT_ATTENUATED);
    }
    if (previous.notBefore && current.notBefore && previous.notBefore.epochMilliseconds > current.notBefore.epochMilliseconds) {
      throw new Error(NOT_BEFORE_BACKWARDS);
    }
  }
  static validateTemporalProperties(token, currentTime) {
    if (token.expiresAt && token.expiresAt.epochMilliseconds <= currentTime.epochMilliseconds) {
      throw new Error(TOKEN_EXPIRED);
    }
    if (token.notBefore && token.notBefore.epochMilliseconds > currentTime.epochMilliseconds) {
      throw new Error(NOT_BEFORE_NOT_MET);
    }
  }
  static validatePoliciesProperties(policies, parameters) {
    if (policies.length > parameters.config.maxPolicyWidth) {
      throw new Error(POLICY_TOO_WIDE);
    }
    for (const policy of policies) {
      const properties = PolicyTreeProperties.fromPolicy(policy);
      if (properties.maxWidth > parameters.config.maxPolicyWidth) {
        throw new Error(POLICY_TOO_WIDE);
      }
      if (properties.maxDepth > parameters.config.maxPolicyDepth) {
        throw new Error(POLICY_TOO_DEEP);
      }
    }
  }
  static validateToken(token, proofs, context, tokenRequirements) {
    switch (token.body.constructor) {
      case DelegationBody:
        _NucTokenValidator.validateDelegationToken(token, tokenRequirements);
        break;
      case InvocationBody:
        _NucTokenValidator.validateInvocationToken(
          token,
          proofs,
          context,
          tokenRequirements
        );
        break;
    }
  }
  static validateDelegationToken(token, tokenRequirements) {
    if (!tokenRequirements) {
      return;
    }
    switch (tokenRequirements.constructor) {
      case InvocationRequirement:
        throw new Error(NEED_INVOCATION);
      case DelegationRequirement:
        if (!token.audience.isEqual(tokenRequirements?.audience)) {
          throw new Error(INVALID_AUDIENCE);
        }
    }
  }
  static validateInvocationToken(token, proofs, context, tokenRequirements) {
    const tokenJson = token.toJson();
    for (const proof of proofs) {
      _NucTokenValidator.validatePolicyEvaluates(proof, tokenJson, context);
    }
    if (!tokenRequirements) {
      return;
    }
    switch (tokenRequirements.constructor) {
      case DelegationRequirement:
        throw new Error(NEED_DELEGATION);
      case InvocationRequirement:
        if (!token.audience.isEqual(tokenRequirements?.audience)) {
          throw new Error(INVALID_AUDIENCE);
        }
    }
  }
  static validatePolicyEvaluates(proof, tokenJson, context) {
    switch (true) {
      case proof.body instanceof InvocationBody:
        throw new Error(PROOFS_MUST_BE_DELEGATIONS);
      case proof.body instanceof DelegationBody: {
        for (const policy of proof.body.policies) {
          if (!policy.evaluate(tokenJson, context)) {
            throw new Error(POLICY_NOT_MET);
          }
        }
      }
    }
  }
  static sortProofs(hash, proofs) {
    const indexedProofs = proofs.map((proof) => [
      proof.computeHash(),
      proof.token
    ]);
    const sortedProofs = [];
    let nextHash = hash;
    while (nextHash) {
      const nextProofIndex = indexedProofs.findIndex(
        ([hash2, _]) => bytesToHex6(hash2) === bytesToHex6(nextHash)
      );
      if (nextProofIndex < 0) {
        throw new Error(MISSING_PROOF);
      }
      const nextProof = indexedProofs.splice(nextProofIndex, 1)[0][1];
      sortedProofs.push(nextProof);
      if (nextProof.proofs.length > 1) {
        throw new Error(TOO_MANY_PROOFS);
      }
      nextHash = nextProof.proofs[0];
    }
    if (indexedProofs && indexedProofs.length > 0) {
      throw new Error(UNCHAINED_PROOFS);
    }
    return sortedProofs;
  }
};
var PolicyTreeProperties = class _PolicyTreeProperties {
  constructor(properties) {
    this.properties = properties;
  }
  get maxDepth() {
    return this.properties.maxDepth;
  }
  set maxDepth(value) {
    this.properties.maxDepth = value;
  }
  get maxWidth() {
    return this.properties.maxWidth;
  }
  set maxWidth(value) {
    this.properties.maxWidth = value;
  }
  static fromPolicy(rootPolicy) {
    switch (true) {
      case rootPolicy instanceof And:
      case rootPolicy instanceof Or: {
        const properties = new _PolicyTreeProperties({
          maxDepth: 0,
          maxWidth: rootPolicy.conditions.length
        });
        for (const policy of rootPolicy.conditions) {
          const innerProperties = _PolicyTreeProperties.fromPolicy(policy);
          properties.maxDepth = Math.max(
            innerProperties.maxDepth,
            properties.maxDepth
          );
          properties.maxWidth = Math.max(
            innerProperties.maxWidth,
            properties.maxWidth
          );
        }
        properties.maxDepth += 1;
        return properties;
      }
      case rootPolicy instanceof Not: {
        const properties = _PolicyTreeProperties.fromPolicy(
          rootPolicy.condition
        );
        properties.maxDepth += 1;
        return properties;
      }
      case rootPolicy instanceof Equals:
      case rootPolicy instanceof NotEquals: {
        return new _PolicyTreeProperties({ maxDepth: 1, maxWidth: 1 });
      }
      case rootPolicy instanceof AnyOf: {
        return new _PolicyTreeProperties({
          maxDepth: 1,
          maxWidth: rootPolicy.options.length
        });
      }
      default:
        throw new Error("policy is not supported");
    }
  }
};
export {
  And,
  AndSchema,
  AnyOf,
  AnyOfSchema,
  BuildSchema,
  CHAIN_TOO_LONG,
  COMMAND_NOT_ATTENUATED,
  Command,
  CommandSchema,
  ConnectorSchema,
  CreateTokenResponseSchema,
  DIFFERENT_SUBJECTS,
  DecodedNucToken,
  DecodedNucTokenSchema,
  DelegationBody,
  DelegationBodySchema,
  DelegationRequirement,
  Did,
  DidSchema,
  EpochSeconds,
  Equals,
  EqualsSchema,
  GasLimitSchema,
  HeaderSchema,
  HexSchema,
  INVALID_AUDIENCE,
  INVALID_SIGNATURES,
  ISSUER_AUDIENCE_MISMATCH,
  InvocationBody,
  InvocationBodySchema,
  InvocationRequirement,
  KeplrPayerBuilder,
  Keypair,
  LookupRevokedTokenResponseSchema,
  MISSING_PROOF,
  NEED_DELEGATION,
  NEED_INVOCATION,
  NOT_BEFORE_BACKWARDS,
  NOT_BEFORE_NOT_MET,
  NilChainAddress,
  NilChainAddressPrefix,
  NilChainProtobufTypeUrl,
  NilToken,
  NilauthAboutResponseSchema,
  NilauthClient,
  NilauthHealthResponseSchema,
  Not,
  NotEquals,
  NotEqualsSchema,
  NotSchema,
  NucToken,
  NucTokenBuilder,
  NucTokenDataSchema,
  NucTokenEnvelope,
  NucTokenEnvelopeSchema,
  NucTokenSchema,
  NucTokenValidator,
  OfflineSignerSchema,
  OperatorSchema,
  Or,
  OrSchema,
  POLICY_NOT_MET,
  POLICY_TOO_DEEP,
  POLICY_TOO_WIDE,
  PROOFS_MUST_BE_DELEGATIONS,
  Payer,
  PayerBuilder,
  PayerConfigSchema,
  PolicySchema,
  PolicyTreeProperties,
  PrivateKeyBase16,
  PublicKeySchema,
  REVOKE_COMMAND,
  ROOT_KEY_SIGNATURE_MISSING,
  RevokedTokenSchema,
  SUBJECT_NOT_IN_CHAIN,
  Selector,
  SelectorSchema,
  SubscriptionCostResponseSchema,
  SubscriptionDetailsSchema,
  SubscriptionStatusResponseSchema,
  TOKEN_EXPIRED,
  TOO_MANY_PROOFS,
  TxHash,
  UNCHAINED_PROOFS,
  ValidatePaymentResponseSchema,
  ValidationParameters,
  assertType,
  base64UrlDecode,
  base64UrlDecodeToBytes,
  base64UrlEncode,
  createSignedRequest,
  extractResponseJson,
  extractResponseText,
  generateNonce,
  pairwise,
  parseEpochSeconds,
  parseWithZodSchema,
  randomBytes,
  toHex,
  unwrapEffect
};
//# sourceMappingURL=lib.js.map